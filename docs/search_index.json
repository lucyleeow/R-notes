[
["index.html", "R notes Chapter 1 Preface", " R notes Lucy Liu 2019-03-08 Chapter 1 Preface These are my notes on R. I used the bookdown package by YiHui Xie. In particular the bookdown book was very thorough and extrememly useful. "],
["introduction.html", "Chapter 2 Introduction 2.1 R files 2.2 Packages 2.3 Basics 2.4 Help 2.5 Data types 2.6 Data structures 2.7 NAs 2.8 Importing &amp; exporting 2.9 Saving objects", " Chapter 2 Introduction Useful references: Hadley Wickham’s Advanced R and R for data science (Answers to questions by jrnold) Technical foundations of informatics CRAN contributed documentation STHDA R comes as a single binary executable file and large number of functions. The binary file has been compiled from source code written using C. Most of the analytic functions are written in R, other languages such as C and fortran are used to write the most fundamental R functions. 2.1 R files .rdata = saves the objects that exist in a session (i.e. everything in environment). If you load .rdata all the objects will be loaded. These objects are part of your ‘workspace’. When you quit R, it asks if you want to save your workspace by default (you can change this in Tools &gt; Global options). It is referring to all the objects in your environment. .rhistory = saves the commands you have executed .R = R script .Rmd = R markdown file (R markdown or R notebooks saved thus) .html = R notebooks can create html file (you can change the output by changing (“output: html_notebook”) at the start of the notebook.). .Rproj.user = hidden directory, where project specific temp files are stored. This file is automatically added to .gitignore. .rprofile = configuration file, usually does not exist in a fresh install 2.1.1 Memory R sets the environment variable ‘R_MAX_VSIZE’ which specifies the maximal vector heap size. It is generally set to the max of: 16GB and available physical memory. This is to avoid having the R process killed when OS over-commits memory. You can override this by creating a temporary environment variable or changing R_MAX_VSIZE in the file ‘.Renviron’. You do risk over allocating and killing the process though. See this SO question for more. 2.1.2 R project R projects is a RStudio product that ‘makes it straightforward to divide your work into multiple contexts, each with their own working directory, workspace, history, and source documents’. Starting a new project creates a .rproj file in the specified working directory. This file contains various project options and can be used as a shortcut for opening the project from the file system. Also creates a hidden directory (.Rproj.user) to store temporary project specific files. It is associated with a R working directory but can be created in a directory with existing R code and data. It stores ‘metadata’ such that when you close your RStudio session, it saves your .rdata and .rhistory, information about your window state, active tabs to your working direction. When you open the same project, it loads all these files and settings and sets your working directory to the one of this project - so your new session looks just as it were before you closed the project. Scripts (.r or .rmd) files are stored separately. The .rproj file is just a text file and looks like this (this is a R package project): Version: 1.0 RestoreWorkspace: No SaveWorkspace: No AlwaysSaveHistory: Default EnableCodeIndexing: Yes Encoding: UTF-8 AutoAppendNewline: Yes StripTrailingWhitespace: Yes BuildType: Package PackageUseDevtools: Yes PackageInstallArgs: --no-multiarch --with-keep.source PackageRoxygenize: rd,collate,namespace To modify go into projects menu on the top RHS of RStudio &gt; Project Options: See RStudio and R pacakges for more details. 2.2 Packages A package bundles together code, data, documentation, and tests and is an easy way to share code with others. Most are hosting on CRAN. install.packages('dplyr') - downloads package from the internet onto your computer. Package name needs to be in quotes. These are downloaded from CRAN. library('dplyr') - Opens the library into the current R session. Does NOT need to be quoted. installed.packages() - Shows you what packages are installed update.package() remove.package() On Linux (and maybe Macs?) I’ve found that problems installing packages in R can sometimes be solved by installing using terminal e.g. sudo apt-get install r-cran-rgl. To make clear where a function is coming from you can use: package::function() e.g. dplyr::mutate() When you load a package it may warn you of ‘conflicts’ - this means that some function names of the package are the same as the function name in r-base. This may be because the package has ‘improved’ or changed the base r function intentionally. To use the original r-base function you must fully specify the function to make clear where it is coming from. E.g. for dplyr, filter() is a conflict. To use base-r function: stats::filter() 2.2.1 Library A library is a directory containing your installed packages. You generally have 2: One for packages that come with every R installation (base, stats etc) One for packages that you have installed. They are normally based on the version of R you are using (e.g. if you have have a folder named ‘3.4’, packages installed when using this R version will be stored here). Sometimes it may seems like you lose all of your packages when you reinstall R — they’re still on your hard drive, but R can’t find them. .libPaths() tells you which libraries are currently active. When you use library(package), R will look through each path in .libPaths to see if a directory called ‘package’ exists. See Advanced R for more and this SO question to find the location of installed packages. 2.2.2 Bioconductor Bioconductor is a source of open source software especially for genomic data analysis. To download packages from bioconductor you will need the top two functions: source(&quot;http://bioconductor.org/biocLite.R&quot;) # Downloads installer script biolite(“limma”) # installer function biolite() #this will install core packages or update any installed packages 2.3 Basics alt + shift + k - shows list of keyboard shortcuts. Indexing is base 1 (i.e. you start counting from 1) Everything is an object in R. Class is blueprint for object, and object is something created using blueprint for object. Many objects can be made from one blueprint/for one class. Create an object by assigning them. Assign variable using &lt;-. You can also use = but this is not advised according to R style guides. There is a difference between &lt;- and =. With &lt;- you can a assign a variable during a function call e.g. f(x &lt;- 3) - which means ‘assign 3 to x, and call f with the first argument set to the value 3’. See this blog for more. get() will return the value of a named object var1 = &quot;Ice bear&quot; get(&quot;var1&quot;) ## [1] &quot;Ice bear&quot; The object name needs to be given as character string. Without quotes this occurs: get(var1) ## Error in get(var1): object &#39;Ice bear&#39; not found Without quotes it evaluates var1, the result of which is a string called ‘Ice bear’. It then searches for a variable called ‘Ice bear’. To set working directory: setwd:('D:/path to wd') or via session -&gt; set working directory. getwd() to get the working directory. To cancel commands use Esc. If R is waiting for you to finish code, a + will be shown in the console instead of &gt;. Comparing numbers: ‘==’ fine for integers but use all.equal() for decimals due to machine representing decimals to certain precision, ‘machine numeric tolerance’ Environment - Objects created in for loops are global objects and objects created in functions are local (See Advanced R for more). &amp; is vectorised and &amp;&amp; is not. Similar for | and ||. See this SO question for more. 12 | 3 is evaluated to be TRUE because if you coerce a number into a logical, any non-zero number will be TRUE and 0 will be FALSE. Thus 12 | 3 is essentially TRUE | TRUE which is TRUE. as.logical(0) ## [1] FALSE as.logical(-3) ## [1] TRUE 2.3.1 Arithmetic When comparing numbers == fine for integers but use all.equal() for decimals due to machine representing decimals to certain precision (‘machine numeric tolerance’). identical() - ‘the safe and reliable way to test two objects for being exactly equal’ Different from all.equal() which allows for small differences in NUMERIC results. Integer division: divide then round down - 598 %/% 100 = 5 Remainder: Gives remainder after division - 598 %% 100 = 98 2.4 Help To access the help file for an object use ?function_name or help(function_name). If you don’t really know the function, you can do a fuzzy search - ??function_name. A summary of packages broken down by topic can be found at CRAN When asking for help online these functions will be useful: dput() - will dump the data you’re working with into a format so that it can be copy and pasted by anyone else into their R session. sessionInfo() - will print out your current version of R, as well as any packages you have loaded. This can be useful for others to help reproduce and debug your issue. 2.5 Data types Double (dbl) - decimal e.g. 3.14 Integer (int) - No decimal e.g. 1 (can be 1L, the L suffix denotes? integer) Complex - imaginary number e.g. 1i Logical (lgl) - Boolean, TRUE or FALSE (T or F) Character (chr) - String Factor (fctr) - Categorical values Date time (dttm) - Date and time Date (date) - Date 2.5.1 Numeric Numbers are usually stored as class = numeric. Numeric actually consists of multiple classes: integer, single precision and double precision (the last classes are floating point numbers). This is because R will automatically convert between the numeric classes when needed, thus it does not matter to the casual user if the number ‘3’ is stored as double or integer. Note that most calculations are done using doubles (as they are more flexible and higher range of values can be expressed as double), thus this is the default storage. However, integers require less space, thus if you have large data structure, that will never need to be converted into double, you can specify it to be stored as integer. Putting a ‘L’ at the end of a number forces it to be an integer (you cannot do this if the number has a decimal point in it). 1:3 will also return a vector of integers. See this SO question for more. 2.5.2 Coercion All elements of an atomic vector must be the same type, so when you attempt to combine different types they will be coerced to the most flexible type. This way no data is lost. logical -&gt; integer -&gt; double -&gt; complex -&gt; character (most flexible) When a logical vector is coerced into an integer or double, TRUE=1 and FALSE=0. This can be useful to calculate sum() (total number of trues) and mean() (proportion of trues). Coercion often happens automatically. Mathematical functions will coerce to double or integer and logical operations (|, &amp;, any()) will coerce to logical. You will usually get a warning message if coercion may cause loss of information. Some string functions will coerce factors to strings e.g. gsub() and grepl(). Some will throw an error, e.g. nchar(). Some will use the underlying integer values c(). It is best to explicitly convert factor vectors to string if you need to perform string functions 2.5.3 Factors Factors are integers ‘under the hood’ - each number corresponds to a level. typeof(factor) will be integer BUT class(factor) will be factor. R can store nominal (categorical data) as factors. R will store the nominal values as a vector of integers. (e.g. nominal values are: red, green, blue, R will associate 1 = red, 2 = blue, 3 = green, and store them as such). The “level’s” are stored as ‘attributes’ found with the function attributes(). my_fact &lt;- as.factor(c(&quot;red&quot;, &quot;blue&quot;)) attributes(my_fact) ## $levels ## [1] &quot;blue&quot; &quot;red&quot; ## ## $class ## [1] &quot;factor&quot; If data is stored as a factor will treat as categorical data or ordinal data in statistical analysis. This, it can be useful when you know all the values a variable can take. However, you can’t add another nominal value that does not already exist, unless you add that nominal value first. Factors can also be used to store ordinal data (i.e small, medium large - data with order but where the intervals not necessarily equal) as ordered factors. E.g. a variable coded as “large”, “medium” &amp; “small’ - rating &lt;- ordered(rating) recodes rating to 1,2,3 and associates 1=large, 2=medium, 3=small internally. R now treats rating as ordinal. A variable can be converted to a factor using as.factor() or factor(). The difference between these two functions is that as.factor() is like a wrapper for factor() that allows quick return if the input vector is already a factor. Performance of as.factor() is thus better if the input is already a factor. ‘Quick return’ will leave factor levels as they are while factor() will not. See this SO question for more. 2.5.3.1 Changing factor order You can use options in the factor() and ordered() functions to control the mapping of integers to strings (overriding the alphabetical ordering). E.g. mydata &lt;- c(&quot;case&quot;, &quot;control&quot;, &quot;control&quot;, &quot;case&quot;) factor_ordering_example &lt;- factor(mydata, levels = c(&quot;control&quot;, &quot;case&quot;)) This tells R that control = 1 and case = 2. str(factor_ordering_example) ## Factor w/ 2 levels &quot;control&quot;,&quot;case&quot;: 2 1 1 2 2.5.3.2 Factors during parsing It may not be immediately obvious that a column is stored as factors. When parsing in data there is an option of not using factors. By default, R always transforms character vectors to factors when creating a dataframe with character vectors or converting a character matrix to a dataframe. A problem with this default behaviour is that it will convert numerical columns of data into a factor if there is a non-numeric value in your column (e.g. a missing value encoded by a character). This can be a nasty cause of errors in your code if you’re not aware of it. To convert factor data into numeric: remove all character values convert to character convert to numeric. If you just convert straight to double/integer without going through character, you will get the numeric levels of the factor instead of the actual data (levels) of the data. You can avoid R converting character data into factors by specifying the argument stringsAsFactors=FALSE when reading in data. Or use na.strings is also useful, to specify what should be read in as NA. 2.6 Data structures Dimensions Homogenous Heterogenous 1D Atomic vector List 2D Matrix Dataframe nD Array Vector is an umbrella term for both atomic vectors and lists, however most people mean atomic vector when they talk about ‘vectors’. Matrices and dataframes can be ‘1D’ (by having only one column or row) but will behave differently from vector. In a dataframe, different columns can contain different data types but all data within one column has to be the same data type. There are no scalar values (0d), individual values are actually atomic vectors with length 1. The function str() (structure) is useful to find out the structure of ab object. If you are using print(str(c(1,2)), there will be a NULL added to the end of that print. This is because the result of str() has a class NULL. Note that you do not need to add print() because str() prints by default. 2.6.1 Atomic vector All elements must be same type (mode). All elements have to be of a basic ‘atomic’ vector data type: Typeof mode storage.mode Logical logical logical Integer numeric integer Double numeric double Complex complex complex Character character character Raw raw raw Create with c() which means means combine or concatenate. Many arithmetic operations are ‘vectorised’, this means that if you perform an arithmetic function on a dataframe, the result be a dataframe. You can test if an object is an atomic vector using is.atomic(). is.vector() returns true if the object is a vector with no attributes apart from names. use is.character(), is.double(), is.integer(), is.logical() to test a vector to see what data type it is composed of. is.numeric(), is a general test for numberliness and will return true for both integer and double vectors. 2.6.2 Lists A list is a 1D ordered collection of objects. Each element can be of any datatype and data structure. For example, you can have a list of lists. l1 &lt;- list(list(1, 2), c(3, 4)) l2 &lt;- c(list(1, 2), c(3, 4)) str(l2) ## List of 4 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : num 4 c() will combine several lists into a vector. If given both atomic vectors and lists, will coerce atomic vector into a list before combining. Lists are sometimes called recursive vectors as lists can contain other lists. This makes them fundamentally different from atomic vectors, which are ‘flat’. l &lt;- list(list(list(list()))) str(l) ## List of 1 ## $ :List of 1 ## ..$ :List of 1 ## .. ..$ : list() l &lt;- c(1, c(2, c(3, 4))) str(l) ## num [1:4] 1 2 3 4 unlist() will turn a list into an atomic vector, if there are different data types in the list, it will coerce them to be the same type. as.vector() will not do this. 2.6.3 Matrix 2D data structure, made up of vectors. All vectors must be of the same data type. Create using: matrix(vector, nrow=x, ncol=y, byrow=FALSE #matrix fills by columns, which is the default. dimnames=(row_names, column_names)) #name your cols and rows Can also modify a vector into a matrix by setting the dim() attribute. v &lt;- 1:6 dim(v) &lt;- c(3, 2) class(v) ## [1] &quot;matrix&quot; You can have matrix where each ELEMENT is a list! m_list&lt;-matrix(list(&#39;1&#39;,2,3,4),2,2) m_list ## [,1] [,2] ## [1,] &quot;1&quot; 3 ## [2,] 2 4 Here the output looks like the matrix is of character and integer. However, each element in the matrix is a list of one! m1 &lt;- matrix(c(list(1), list(2), list(3), list(4)), 2, 2) str(m1) ## List of 4 ## $ : num 1 ## $ : num 2 ## $ : num 3 ## $ : num 4 ## - attr(*, &quot;dim&quot;)= int [1:2] 2 2 typeof(m1) ## [1] &quot;list&quot; m2 &lt;- matrix(1:4, 2, 2) str(m2) ## int [1:2, 1:2] 1 2 3 4 typeof(m2) ## [1] &quot;integer&quot; 2.6.4 Array An array is like a matrix but can have &gt;2 dimensions. Like vectors, the content of the array is stored in a vector in column-major order and the dim attribute is a vector of integers specifying the respective extents of the array. There is no difference between a matrix and a 2D array. 2.6.5 Dataframes Dataframes consist of a list of equal length vectors. class() is dataframe but typeof() gives list. length() will give the length of the list (i.e. ncol()). You can create a dataframe by joining vectors: employee &lt;- c(&#39;John Doe&#39;,&#39;Peter Gynn&#39;,&#39;Jolie Hope&#39;) salary &lt;- c(21000, 23400, 26800) employ.data &lt;- data.frame(employee, salary) cbind() (with vectors) will create matrix unless one of the arguments is already a dataframe. When combining column-wise, the number of rows must match, but row names are ignored. When combining row-wise, both the number and names of columns must match. You an use plyr::rbind.fill() to combine data frames that don’t have the same columns. You can also coerce an object to a data frame with as.data.frame(). A vector will create a one-column data frame. A list will create one column for each element; there will be an error if they’re not all the same length. A matrix will create a dataframe with the same number of columns and rows as the matrix. It is possible to store a list as a column in a dataframe: df &lt;- data.frame(x = 1:3) df$y &lt;- list(1:2, 1:3, 1:4) df ## x y ## 1 1 1, 2 ## 2 2 1, 2, 3 ## 3 3 1, 2, 3, 4 However, this will give an error as it tries to put each item of the list into its own column, which fails as they have different number of rows. data.frame(x = 1:3, y = list(1:2, 1:3, 1:4)) ## Error in (function (..., row.names = NULL, check.rows = FALSE, check.names = TRUE, : arguments imply differing number of rows: 2, 3, 4 You can use I(), which causes the dataframe to treat list as one unit: dfl &lt;- data.frame(x = 1:3, y = I(list(1:2, 1:3, 1:4))) dfl ## x y ## 1 1 1, 2 ## 2 2 1, 2, 3 ## 3 3 1, 2, 3, 4 str(dfl) ## &#39;data.frame&#39;: 3 obs. of 2 variables: ## $ x: int 1 2 3 ## $ y:List of 3 ## ..$ : int 1 2 ## ..$ : int 1 2 3 ## ..$ : int 1 2 3 4 ## ..- attr(*, &quot;class&quot;)= chr &quot;AsIs&quot; The class AsIs is added but this can be safely ignored. It is NOT wise to do this though as many functions that work on dataframes will assume that all columns are atomic vectors. You can subsetting dataframe a number of different ways: name_of_table$name_of_column name_of_table[row,column] name_of_table[,c(&#39;name_of_col_1&#39;)] 2.6.6 High dimension structures The high dimension equivalent of vector functions: length() - dim(). You can also use row() and ncol() for matrices. names() - dimnames() outputs a list of character vectors of the names. You can also use rownames() and colnames() for matrices. c() - cbind() and rbind() There is a drop argument when using [ ] to subset high dimension data structures. Drop = Drop Redundant Extent Information. It is a logical which determines whether the dimensions of an array which have only one level should be deleted. What is does is, when subsetting to get only one row/column (from a matrix/array), you can set drop=TRUE to get a vector. If drop=FALSE, you get the same data structure, but with just one row. See this question for more. 2.6.7 Attributes All objects can have attributes, used to store metadata about the object. They can be thought of as a named list. y &lt;- 1:10 attr(y, &quot;my_attribute&quot;) &lt;- &quot;This is a vector&quot; # create an attribute called “my_attribute” and give it some content attr(y, &quot;my_attribute&quot;) ## [1] &quot;This is a vector&quot; # access an individual attribute with attr() str(attributes(y)) ## List of 1 ## $ my_attribute: chr &quot;This is a vector&quot; structure() (instead of str()) will return the object with attribute set as well. structure(y) ## [1] 1 2 3 4 5 6 7 8 9 10 ## attr(,&quot;my_attribute&quot;) ## [1] &quot;This is a vector&quot; By default you lost most (NOT all) attributes when modifying a vector. attributes(sum(y)) ## NULL Attributes you don’t lose: Names Dimensions (can be used to turn vectors into matrices and arrays) Class Each of these attributes has a special accessor function; names(), dim(), class(). (Do not use attr(x, 'names')) 2.6.7.1 Names You can name a vector a number of ways: x &lt;- c(a = 1, b = 2, c = 3) x &lt;- 1:3; names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) x &lt;- 1:3; names(x)[[1]] &lt;- c(&quot;a&quot;) x &lt;- setNames(x, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) #assigns names to an object and returns the object Names don’t have to be unique but you can subset by names when they are Not all elements need to have a name. If some are missing when you create the vector the name will be set to be an empty string However if you modify a vector ‘in place’ by setting name, names() will return NA for the missing ones. y &lt;- c(a = 1, 2, 3) names(y) ## [1] &quot;a&quot; &quot;&quot; &quot;&quot; v &lt;- c(1, 2, 3) names(v) &lt;- c(&#39;a&#39;) names(v) ## [1] &quot;a&quot; NA NA If all names are missing, names() will return NULL. z &lt;- c(1, 2, 3) names(z) ## NULL To remove names from vector use names(x) &lt;- NULL or unname(). There is a package called ‘sticky’ which will force defined attributes to be kept - as they are lost when common functions (e.g. subset/extend/extract are used). 2.7 NAs NAs = not availables ‘NAs are contagious’ - most equations involving NA returns NA. If there is a NA value, mean() will return NA. It makes sense that the mean of a group of numbers plus a missing value that could be anything is NA. To get it to return the mean of the non-missing values use mean(x, na.rm=TRUE) As all values in an atomic vector must be of the same data type, there are several ‘types’ of NAs. The default type is logical: str(NA) ## logi NA NA will be coerced into the correct type if used within c(). v &lt;- c(1,2,3,4,5, NA) str(v[6]) ## num NA v &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, NA) str(v[4]) ## chr NA Many functions will have a na.rm argument. You can also remove NA’s using is.na(). v &lt;- c(1,2,3,NA) is.na(v) ## [1] FALSE FALSE FALSE TRUE v[! is.na(v)] ## [1] 1 2 3 In certain equations, including NA will not return NA. This is when the result of the operation would be the same for all possible values of NA: NA ^ 0 ## [1] 1 This is because any number to the power of 0 is 1 (including 0^0). NA | TRUE ## [1] TRUE Here TRUE is returned and NOT NA because no matter if the NA value is TRUE or FALSE, both will be TRUE. It is ignored by functions such as filter(). 2.7.0.1 NA vs NaN There is a difference. NaN - Not a Number e.g. undefined calculations such as 3/0. Exists only as double type for real or imaginary components of the complex type. is.nan() only checks for NaN. Does not return true for NAs. is.na() returns TRUE for NA and NaNs. When matching - NaN will match NaN only (not NA). NA - Not Available - usually a missing value. From R1.5.0 the string ‘NA’ is distinct from NA of character type. String ‘NA’ should be written as as.character(NA). For more see this blog. 2.8 Importing &amp; exporting read.table(), read.csv(), read.delim() are all in same family. They read in files and output dataframes. scan() also reads in files but outputs a list or vector (See datacamp for more) read.fwf() ‘fixed width files’ - will let you read in any type of ASCII file. Each column in the data is a fixed width, thus no uniform separation of cells in row. (See this SO question for more) write.table() is the base R function for writing out data. If your data has rownames, using default arguments results in a ‘missing’ column name - because there is no column name for the rownames column. Set col.names = NA and row.names = TRUE to write out a blank cell where the column name for the rownames column is. This is the convention used for CSV files to be read by spreadsheets. 2.9 Saving objects You can save objects in your environment as a .Rdata file using save() and laod then into a new session using load(). YiHui recommends saveRDS() and loadRDS() because you can silently overwrite current object using save() and load(). 2.9.1 feather The feather package allows you to save objects in fast binary format that can be shared across programming languages (i.e. usable outside of R). Tends to be faster than ‘RDS’. library(feather) write_feather(challenge, &quot;challenge.feather&quot;) read_feather(&quot;challenge.feather&quot;) "],
["data-wrangling-base-r.html", "Chapter 3 Data wrangling - base R 3.1 Useful functions 3.2 Subsetting 3.3 Apply family 3.4 do.call() 3.5 do.call vs lapply vs map", " Chapter 3 Data wrangling - base R 3.1 Useful functions floor() returns the largest integer not greater than the input number(s) floor(2.6) ## [1] 2 ceiling() returns the smallest integer not less than the input number(s) ceiling(2.6) ## [1] 3 sort() returns sorted vector. Sorts alphabetically/numerically, depending on the data type. decreasing lets you inverse order. sort(iris$Sepal.Length[1:10]) ## [1] 4.4 4.6 4.6 4.7 4.9 4.9 5.0 5.0 5.1 5.4 order() gives the indicies of the vector in sorted order. For example, if you wanted to sort a dataframe according to the values in one column you can use: head( iris[order(iris$Sepal.Length),] ) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 14 4.3 3.0 1.1 0.1 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 39 4.4 3.0 1.3 0.2 setosa ## 43 4.4 3.2 1.3 0.2 setosa ## 42 4.5 2.3 1.3 0.3 setosa ## 4 4.6 3.1 1.5 0.2 setosa match() orders the 1st argument according to the 2nd argument. For example, if you wanted to order a vector of strings according to a specific order defined by another vector of strings: # define vectors a &lt;- c(&quot;a&quot;,&quot;c&quot;,&quot;b&quot;) b &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;) # the order we want match(a,b) ## [1] 1 3 2 Match says that in the vector “b”, the first element should be 1st, the second “c” should be 3rd and the last one “b” should be 2nd. If you wish to order a you can use: a[match(a,b)] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; %in% finds matches in the RHS vector and returns a vector of logicals the same length as the LHS vector. c(1,3,5) %in% 1:3 ## [1] TRUE TRUE FALSE intersect finds the common elements in two vectors. setdiff() looks for differences between two vectors. Order matters - e.g. setdiff(a,b) gives you things that are in a BUT not in b. merge() joins two dataframes together, by common columns or rownames. Arguments: by - name of the column(s) to merge by in BOTH dataframes (implies that both dataframes have the same column names). by.x, by.y - name of the column(s) in the first dataframe (x) and the second dataframe (y) to merge by. Use this if the columns to merge by are named differently in the two dataframes. all - should all the rows in both dataframes be kept? If there are rows in one dataframe but not the other, the missing data will be filled with NAs. all.x, all.y - lets you specify if you want to keep all rows in either the first x or second y dataframe only. merge() is a generic function in base R. It dispatches to either the merge.data.frame method or merge.data.table method depending on the class of its first argument (see link for more details) aggregate() ‘Splits the data into subsets, computes summary statistics for each, and returns the result in a convenient form’. It requires three things: The object to perform function on, e.g a dataframe. Note that if you do not specify the columns of interest, the function will be performed on all columns. What variables to group by. Must give as list e.g. by = list(df$var1, df$var2). If using a dataframe, the output dataframe will have a column for each grouping variable - to specify which grouping variable each row is. The default column name is group1, group2… If you wish to specify the name of the column use by = list(mycolname = df$var1, df$var2) Function to perform. Any other arguments to be passed to function can be given after comma. Example: aggregate(iris[,1:4], by = list(Species2 = iris$Species), mean, na.rm = TRUE) ## Species2 Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 setosa 5.006 3.428 1.462 0.246 ## 2 versicolor 5.936 2.770 4.260 1.326 ## 3 virginica 6.588 2.974 5.552 2.026 complete.case() gives you a logical vector, the same length as the number of rows of your dataframe/matrix, telling you if there is a NA in your row. is.finite() tells you if it is finite (e.g. will return false for Inf, -Inf, NaN, NA) 3.2 Subsetting Useful references: Advanced R, R manual [ ] - Returns an object that is of the same type as original UNLESS the one exception is when your subset only has one result). The default is to reduce results to the lowest dimension. E.g. taking a subset of 1 column in a df returns a vector. You can override this to return a df by using argument drop=false (iris[ , &quot;Petal.Length&quot;, drop=FALSE ]). For arrays, it will return array with lowest possible dimensionality. You can also use it to obtain a vector longer than the original. E.g: a &lt;- c(&quot;black&quot;, &quot;red&quot;) a[c(1,2,1,1)] ## [1] &quot;black&quot; &quot;red&quot; &quot;black&quot; &quot;black&quot; [[ ]] Extracts one element. For vector = single value, df = column, list = one element. Result is not necessarily the same data structure as the original. Important for list as using [ ] on a list returns a list. E.g. for a list of dataframes, list1[1] returns a list with one element - a dataframe, list1[[1]] returns a dataframe. As [[ ]] can only return a single value, it must be used with single positive integer or string (name). With [ ] you can input a vector and get several elements of the container. $ Can be used for recursive objects - lists and pairlists. Can only give it a character or symbol as the index The following are difference ways to subset: Positive integer returns elements at the specific positions. If index duplicated, will return element twice. If decimal number given, will be silently truncated (NOT rounded) to integer. Negative integer omits the specified elements. You can’t mix positive and negative integers, will return an error. Logical vector selects for element where corresponding boolean is TRUE. Will be recycled if shorter than vector. Character vector can be used if the vector is named. Names matched exactly. NA - an NA in the index will either return an NA value at a NA index: iris[c(NA,2,NA,4),1:2] ## Sepal.Length Sepal.Width ## NA NA NA ## 2 4.9 3.0 ## NA.1 NA NA ## 4 4.6 3.1 or if only one NA is used, will return an object the same length, completely filled with NAs. Below there are 150 rows (the same number in the original iris data) and each row is a NA. head( iris[NA,1:2] ) ## Sepal.Length Sepal.Width ## NA NA NA ## NA.1 NA NA ## NA.2 NA NA ## NA.3 NA NA ## NA.4 NA NA ## NA.5 NA NA 3.3 Apply family The apply() functions do not actually offer improved performance over loops, except lapply() which can be a little faster because it does more work in C than in R. Use apply family for clarity (NOT performance) and because it has no side effects (e.g. does not alter the the input dataframe). See this question on SO for more. Datacamp has a nice tutorial on the apply family. apply() - applies a function to either all the rows (MARGIN = 1) or all the columns (MARGIN = 2). Returns vector, array or list depending on the output of the function on the row/column. by() - splits a dataframe by row by by the values of one or more factors and applies a function to each subset. eapply() applies a function to the named values from an environment and returns results as list. This is primative (internally implemented) function. lapply() ‘list apply’ - returns list of the same length as input function. Each element is result of applying a function to the input object. sapply() ‘simplify apply’ - same as lapply() but returns a vector or matrix. (sapply() and lapply() are essentially the same however, lapply always returns a list and sapply tries to simplify.) Do not have to specify index as you do in apply Returns named vector, USE.NAMES = FALSE if you don’t want sapply() to use character values as names for the result. vapply() - returns specified type of value. mapply() ‘multivariate apply’ - allows input of more than one argument. mapply(min, iris$Sepal.Length, iris$Sepal.Width) ## [1] 3.5 3.0 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 3.7 3.4 3.0 3.0 4.0 4.4 3.9 ## [18] 3.5 3.8 3.8 3.4 3.7 3.6 3.3 3.4 3.0 3.4 3.5 3.4 3.2 3.1 3.4 4.1 4.2 ## [35] 3.1 3.2 3.5 3.6 3.0 3.4 3.5 2.3 3.2 3.5 3.8 3.0 3.8 3.2 3.7 3.3 3.2 ## [52] 3.2 3.1 2.3 2.8 2.8 3.3 2.4 2.9 2.7 2.0 3.0 2.2 2.9 2.9 3.1 3.0 2.7 ## [69] 2.2 2.5 3.2 2.8 2.5 2.8 2.9 3.0 2.8 3.0 2.9 2.6 2.4 2.4 2.7 2.7 3.0 ## [86] 3.4 3.1 2.3 3.0 2.5 2.6 3.0 2.6 2.3 2.7 3.0 2.9 2.9 2.5 2.8 3.3 2.7 ## [103] 3.0 2.9 3.0 3.0 2.5 2.9 2.5 3.6 3.2 2.7 3.0 2.5 2.8 3.2 3.0 3.8 2.6 ## [120] 2.2 3.2 2.8 2.8 2.7 3.3 3.2 2.8 3.0 2.8 3.0 2.8 3.8 2.8 2.8 2.6 3.0 ## [137] 3.4 3.1 3.0 3.1 3.1 3.1 2.7 3.2 3.3 3.0 2.5 3.0 3.4 3.0 The function min(), which can take several arguments, is applied to two columns of iris. The result is a matrix with one column and the same number of rows as in iris. For more complex functions, this syntax can also be used. Notice how the two arguments to the function are given at the end. mapply(function(x,y){ funct(x,y)}, input1, input2) rapply() ‘recursive apply’ - applies functions to lists in different ways depending on arguments supplied. E.g. apply to each value in the list or apply to each list. Arguments to the function can usually be given in two different ways: sapply(data, function(x) my_funct(x, arg = TRUE)) sapply(data, my_funct, arg = TRUE) I would suggest to use the first syntax for clarity. 3.3.1 Uses apply() can be used to perform a function on every ‘n’ rows of every column in matrix: iris_sub &lt;- iris[1:4,1:4] iris_sub ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 matrix(iris_sub$Sepal.Length, nrow = 2) ## [,1] [,2] ## [1,] 5.1 4.7 ## [2,] 4.9 4.6 colMeans(matrix(iris_sub$Sepal.Length, nrow = 2)) ## [1] 5.00 4.65 The mean of every two rows of the Sepal.Length column is being calculated. The result of our function is a vector. apply(iris_sub, 2, function(x) colMeans(matrix(x, nrow = 2))) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## [1,] 5.00 3.25 1.4 0.2 ## [2,] 4.65 3.15 1.4 0.2 apply() gives the function a column of the dataframe each ‘iteration’. The result of the function is a vector (see above) and apply() puts these vectors together into a matrix. See this SO question for more. mapply() can be used to apply a function to groups of columns. First, create a list of the columns we want to perform our function on. x &lt;- list(1:2, 3:4) x ## [[1]] ## [1] 1 2 ## ## [[2]] ## [1] 3 4 Using iris_sub from above: rowMeans( iris_sub[, x[[1]] ] ) ## 1 2 3 4 ## 4.30 3.95 3.95 3.85 This is performing rowMeans() the first two columns (x[[1]] = 1,2) of iris_sub for each row. We can use lapply() to perform this on the other elements in x. x is a list of the column indices we wish to perform the function on. The function is performed on columns 1 &amp; 2 and 3 &amp; 4 as per x. lapply(x, function(i) rowMeans( iris_sub[, i ] )) ## [[1]] ## 1 2 3 4 ## 4.30 3.95 3.95 3.85 ## ## [[2]] ## 1 2 3 4 ## 0.80 0.80 0.75 0.85 This can also be combined this together into a matrix (see below for more on do.call()). do.call(cbind, lapply(x, function(i) rowMeans( iris_sub[, i ] ))) ## [,1] [,2] ## 1 4.30 0.80 ## 2 3.95 0.80 ## 3 3.95 0.75 ## 4 3.85 0.85 See this question on SO for more. 3.4 do.call() This function lets you call any function and give it arguments via a list. x &lt;- lapply(iris, class) str(x) ## List of 5 ## $ Sepal.Length: chr &quot;numeric&quot; ## $ Sepal.Width : chr &quot;numeric&quot; ## $ Petal.Length: chr &quot;numeric&quot; ## $ Petal.Width : chr &quot;numeric&quot; ## $ Species : chr &quot;factor&quot; lapply() is performing class() on all columns of the dataframe iris. The result is a list where each element is the class of each column. do.call(c, x) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;numeric&quot; &quot;factor&quot; Here the do.call() function is giving the c() function five arguments, with each argument being an element of the list x. The list ‘x’ is turing into a vector. Further, notice how x is a named list. The output of do.call() was a name vector. Let’s look at a paste example for clarity. a &lt;- c(a = &quot;a&quot;, b = &quot;b&quot;, sep = &quot;.&quot;) do.call(paste, as.list(a)) ## [1] &quot;a.b&quot; What do.call() is actually executing is: paste(a = &quot;a&quot;, b = &quot;b&quot;, sep = &quot;.&quot;) The what argument of do.call() can take ‘either a function or a non-empty character string naming the function to be called’. When you give it the function name - it will take the default function with that name. If you wish to specify which environment to take the function from - you must give the function name in quotes and specify the environment using the envir argument. See this do.call() guide for more. 3.5 do.call vs lapply vs map do.call() lapply() Map There is one function call. Applies a given function to the list as a whole. There are n function calls, where n is the length of the list/vector. Simple wrapper to mapply(). Does not attempt to simplify the result. Often used to assemble lists into simpler structures. Returns a list of the same length as your list/vector. "],
["data-wrangling-tidyverse.html", "Chapter 4 Data wrangling - tidyverse 4.1 Tibbles 4.2 readr 4.3 dplyr 4.4 tidyr", " Chapter 4 Data wrangling - tidyverse 4.1 Tibbles Tibbles are a ‘modern take on dataframes’ and are used extensively in tidyverse. Tibbles are dataframes with some behaviours tweaked: Does not change the type of input (e.g. never changes strings to factors) Never changes names of variables Never creates row names Possible to have column names that are not valid R variable names e.g. can have spaces. To refer to these variables you need backticks. When you print a tibble - only the first 10 rows and all the columns that fit on the screen are shown. The type (e.g. int, dbl) of each column also shown. To view more you can use View() or specify what you want to display with print(n = 10, width = Inf) - which means print 10 rows and all the columns. You can also set up default print options using options(tibble.print_max = n, tibble.print_min = m) Subsetting. You can subset in a pipe: Must use “.” Tibbles will never do partial matching when subsetting. df &lt;- tibble( #making the tibble x = runif(5), y = rnorm(5) ) df %&gt;% .$x ## [1] 0.55511169 0.91431366 0.58313373 0.09013628 0.98014050 df %&gt;% .[[&quot;x&quot;]] ## [1] 0.55511169 0.91431366 0.58313373 0.09013628 0.98014050 If you have set a variable (e.g. var)to be equal to a column name, and want to refer to the variable during subsetting use eval() (e.g. as_tibble(mtcars) %&gt;% .[[eval(var)]]) You can create a tibble using tibble(). Vectors of length 1 will be recycled. You can also refer to a variable you just created. E.g.: tibble( x = 1:5, y = 1, z = x ^ 2 + y ) ## # A tibble: 5 x 3 ## x y z ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 2 ## 2 2 1 5 ## 3 3 1 10 ## 4 4 1 17 ## 5 5 1 26 You can convet a dataframe into a tibble with as_tibble(). tribble() (‘transposed tibble’) is another way of creating tibbles. It is good for small amounts of data. Column headings start with ~ and entries separated by commas: tribble( ~x, ~y, ~z, #--|--|---- # add this to make clear where heading is &quot;a&quot;, 2, 3.6, &quot;b&quot;, 1, 8.5 ) ## # A tibble: 2 x 3 ## x y z ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 2 3.6 ## 2 b 1 8.5 4.2 readr readr determines data type when reading in a file by reading the first 1000 rows and using some heuristics to figure out the type of each column. It tries each of the following and if none of the rules apply it will stay as a vector of strings: logical: contains only “F”, “T”, “FALSE”, or “TRUE”. integer: contains only numeric characters (and -). double: contains only valid doubles (including numbers like 4.5e-5). number: contains valid doubles with the grouping mark inside. time: matches the default time_format. date: matches the default date_format. date-time: any ISO8601 date. To emulate this process you can use guess_parser() which returns readr’s best guess as to type of vector. parse_guess() guesses and uses the guess to parse the vector. There can be problems with larger files: The first 1000 rows may be special cases. A column may contain a lot of missing values. If there are problems, the output will state the column specification for each column generated by looking at the first 1000 rows and the first 5 parsing failures. You can use problems() for more detail. To fix these problems simply manually specify what type of column. challenge &lt;- read_csv( readr_example(&quot;challenge.csv&quot;), col_types = cols(.default = col_character(), #everything is character unless specified below x = col_double(), y = col_character() ) ) Other data types available: * col_integer * col_logical * col_factor (must give levels) * col_guess * col_number (drops any non-numeric number before or after the first number) See CRAN and readr for more. Other tips: Use guess_max argument to set the number of rows to look at to decide on col type. It may be easier to diagnose problems if you read everything in as a character (default = col_character()) and then use type_convert() to apply the parsing heuristics to the character columns. Set the maximum number of rows to read in with n_max() when reading in a largish file and you are trying to fix problems. This will speed up your iterations. Read data into R as a character vector of lines with read_lines() or even character vector of length one with read_file(). It can be idea to specify col types as provides for more reproducible data (e.g. if your data changes). To be strict you can also use stop_for_problems() which will throw up an error and stop your script if there are parsing problems. 4.2.1 Parsing Parsing functions are the building blocks for readr and are used when reading in files. They take a character vector and returns more specialised vector output. Each parse_xx() function complement the corresponding col_xx() function (e.g. parse_double() and col_double()). The difference is that parse_xxx(), parses the data when it is in a character vector in R already whereas col_xx() tells R how to load the data. str(parse_logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;NA&quot;))) ## logi [1:3] TRUE FALSE NA You can add a na argument to specify what should be returned as NA. If something goes wrong, a warning will explain why. It will still be parsed but with the problems excluded. These warnings are similar to read_*() function warnings. If there are many problems, use problems(variable_name) to get complete set. This actually returns a tibble of the problem values in parsing. parse_logical() - Not much can go wrong. parse_integer() - Not much can go wrong. parse_double() - Strict numerical. Dealing with decimals indicated with point or comma: Default is decimal. To over-ride use parse_double(&quot;1,23&quot;, locale = locale(decimal_mark = &quot;,&quot;)). Locale is an object that specifies parsing options. Called locale as these options differ place to place. parse_number() - Flexible numeric. Ignores non-numeric characters before and after the number. parse_number(&quot;It cost $123.45&quot;) ## [1] 123.45 It also deals with grouping marks (e.g. 100,000 or 100.000 or 100’000). parse_number(&quot;123.456.789&quot;, locale = locale(grouping_mark = &quot;.&quot;)) ## [1] 123456789 parse_character() - Problems arise from how characters are encoded. A hexadecimal number represents a byte of information and in turn a character. The mapping between a hexadecimal number to a character is called encoding. ASCII encoding is not good for non-English characters. Previously, there have been competing encodings for non-english characters but now UTF-8 is supported almost everywhere and encodes nearly every character and emojis. Readr uses UTF-8 when writing and assumes your data is UTF-8 encoded when reading it it. This fails for data produced by older systems. To fix this problem you can specify the encoding using locale e.g. parse_character(x1, locale = locale(encoding = &quot;Latin1&quot;)) There may be difficulties in determining the encoding. You can try to find somewhere in data documentation or use guess_encoding() (first argument is either path to file or raw vector). parse_factor() - parses as factor. The levels argument is all the possible ‘levels’ of a factor. It will generate a warning when an unexpected value is present. fruit &lt;- c(&quot;apple&quot;, &quot;banana&quot;) parse_factor(c(&quot;apple&quot;, &quot;banana&quot;, &quot;bananana&quot;), levels = fruit) ## Warning: 1 parsing failure. ## row col expected actual ## 3 -- value in level set bananana ## [1] apple banana &lt;NA&gt; ## attr(,&quot;problems&quot;) ## # A tibble: 1 x 4 ## row col expected actual ## &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 3 NA value in level set bananana ## Levels: apple banana parse_datetime() - Expects an ISO8601 date-time. Components of a date are organised from biggest to smallest: year, month, day, hour, minute, second. If time is omitted it will set it to midnight. parse_datetime(&quot;2010-10-01T2010&quot;) ## [1] &quot;2010-10-01 20:10:00 UTC&quot; parse_date() - Expects a four digit year, a ‘-’ or ‘/’, the month, a ‘-’ or ‘/’, then the day. parse_time() - Expects the hour, ‘:’, minutes, optionally ‘:’ and seconds, and an optional am/pm specifier. Note R does not have a good built in class for time data. Thus the hms package is useful. 4.2.2 Exporting write_csv() and write_tsv() always encode strings in UTF-8 and save date-times in ISO8601 format. write_excel_csv() - use this if you want to import the csv to excel as there is a ‘byte order mark’ which telss excel that you are using UTF-8 encoding. 4.3 dplyr Offers several useful functions. Parameters that go in these functions: The first argument is a dataframe. The subsequent arguments describe what to do with the data frame, using the variable names (without quotes). The result is a new data frame. dplyr functions do not alter original tibble but either prints a new tibble or saves it to a new variable. 4.3.1 Subsetting Subsetting with [ ] will generally return you with a tibble mpg_tib &lt;- as.tibble(mpg) ## Warning: `as.tibble()` is deprecated, use `as_tibble()` (but mind the new semantics). ## This warning is displayed once per session. str(mpg_tib[1,1]) ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 1 obs. of 1 variable: ## $ manufacturer: chr &quot;audi&quot; To convert the above into a character: str(as.character(mpg_tib[1,1])) ## chr &quot;audi&quot; 4.3.2 The pipe %&gt;% The pipe puts the output from the LHS as the first argument of the function on the RHS. It is useful in avoiding ‘intermediate’ variables. To avoid this, you can use curly brackets { } which will not automatically put the piped data as the first argument. mpg %&gt;% {head()} ## Error in head.default(): argument &quot;x&quot; is missing, with no default mpg %&gt;% {head(.)} ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manua… f 21 29 p comp… ## 3 audi a4 2 2008 4 manua… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto(… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto(… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manua… f 18 26 p comp… See this SO question for more details. 4.3.3 filter Filters rows. Several conditions can be used but be careful of notation and precedence: ‘not’, ‘and’ then ‘or’ (see link for more). For example: mpg %&gt;% filter(year == 1999 | 2000 ) ## # A tibble: 234 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows The result is a dataframe with NO rows filtered. This is because R first evaluates: 1999 | 2000 ## [1] TRUE which is TRUE (see ref(888)). Then it evaulates year == TRUE which results in all rows being kept. Instead use the notation: mpg %&gt;% filter(year == 1999 | year == 2000 ) or: mpg %&gt;% filter(year %in% c(1999,2000)) 4.3.4 select Selects for columns. select(mpg, model, displ) # Selects only the columns model and displ select(mpg, model:year) # Selects all columns from model to year inclusive select(mpg, -(model:year)) # Selects all columns EXCEPT model to year inclusive There are a number of helper functions you can use within select(): starts_with(&quot;abc&quot;) - matches names that begin with “abc”. ends_with(&quot;xyz&quot;) - matches names that end with “xyz”. contains(&quot;ijk&quot;) - matches names that contain “ijk”. For the above functions, you can only input one string (NOT a vector of strings) matches(&quot;(.)\\\\1&quot;) - selects variables that match a regular expression. This one matches any variables that contain repeated characters. num_range(&quot;x&quot;, 1:3) - matches columns x1, x2 and x3. one_of() - selects column names that are from a vector consisting of characters. everything() - all remaining columns. This is useful for reordering your columns. See dplyr documentation for more details. 4.3.5 mutate This allows you to add variables to your dataset. New variables often functions of existing variables. mpg[,1:3] %&gt;% mutate(newcol = paste(manufacturer, model), newcol2 = paste(newcol, displ)) ## # A tibble: 234 x 5 ## manufacturer model displ newcol newcol2 ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 audi a4 audi a4 1.8 ## 2 audi a4 1.8 audi a4 audi a4 1.8 ## 3 audi a4 2 audi a4 audi a4 2 ## 4 audi a4 2 audi a4 audi a4 2 ## 5 audi a4 2.8 audi a4 audi a4 2.8 ## 6 audi a4 2.8 audi a4 audi a4 2.8 ## 7 audi a4 3.1 audi a4 audi a4 3.1 ## 8 audi a4 quattro 1.8 audi a4 quattro audi a4 quattro 1.8 ## 9 audi a4 quattro 1.8 audi a4 quattro audi a4 quattro 1.8 ## 10 audi a4 quattro 2 audi a4 quattro audi a4 quattro 2 ## # … with 224 more rows Note that the input is a vector and the output is a vector of the same length. Also note how we are allowed to refer to variables that we have just added. 4.3.5.1 rename Let’s you rename a column. 4.3.5.2 lead, lag &amp; cum* lead() and lag() allow you to create another vector which is offset up or down by a certain amount. Using this you can calculate running differences, or find when values change. Syntax: lead(data, lead_amount) &amp; lag(data, lag_amount) mpg[,3] %&gt;% mutate(lag = lag(displ,1)) ## # A tibble: 234 x 2 ## displ lag ## &lt;dbl&gt; &lt;dbl&gt; ## 1 1.8 NA ## 2 1.8 1.8 ## 3 2 1.8 ## 4 2 2 ## 5 2.8 2 ## 6 2.8 2.8 ## 7 3.1 2.8 ## 8 1.8 3.1 ## 9 1.8 1.8 ## 10 2 1.8 ## # … with 224 more rows When using these two functions with group_by() (see below), lag or lead will give you the lag or lead within that group. cumsum(), cumprod(), cummin(), cummax() give you running sums, products, mins and maxes respectively. dplyr provides cummean() for cumulative means. 4.3.5.3 transmutate If you only want to keep the new column created, use transmutate(). 4.3.6 case_when This is used to change a column, in place and an alternative to ifelse(): x &lt;- 1:20 case_when( x %% 35 == 0 ~ &quot;fizz buzz&quot;, x %% 5 == 0 ~ &quot;fizz&quot;, x %% 7 == 0 ~ &quot;buzz&quot;, TRUE ~ as.character(x) ) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;fizz&quot; &quot;6&quot; &quot;buzz&quot; &quot;8&quot; &quot;9&quot; &quot;fizz&quot; ## [11] &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;buzz&quot; &quot;fizz&quot; &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;fizz&quot; The tilde (~), separates RHS and LHS. RHS is the condition (TRUE/FALSE result) and the LHS is what you want the row to be changed to if TRUE. The last option, TRUE, takes all remaining rows and you can set to what you want. Here, we have set it to be the same value as before (though as.character). You can also create a new column, using case_when within mutate: mpg[,1] %&gt;% mutate(newcol = case_when( manufacturer == &quot;audi&quot; ~ &quot;Audi!&quot;, TRUE ~ .$manufacturer )) ## # A tibble: 234 x 2 ## manufacturer newcol ## &lt;chr&gt; &lt;chr&gt; ## 1 audi Audi! ## 2 audi Audi! ## 3 audi Audi! ## 4 audi Audi! ## 5 audi Audi! ## 6 audi Audi! ## 7 audi Audi! ## 8 audi Audi! ## 9 audi Audi! ## 10 audi Audi! ## # … with 224 more rows 4.3.7 summarise Summarises column(s) using a function that returns one value. E.g. mpg %&gt;% summarise(meanDispl = mean(displ), meanYear = mean(year)) ## # A tibble: 1 x 2 ## meanDispl meanYear ## &lt;dbl&gt; &lt;dbl&gt; ## 1 3.47 2004. It is often used with group_by() - see below. There are also a useful functions that are wrappers around summarise(): count() - this will give you the number of rows in each group, depending on the column name provided. E.g. Here it gives you the number of cars (rows) in each manufacturer group. mpg %&gt;% count(manufacturer) ## # A tibble: 15 x 2 ## manufacturer n ## &lt;chr&gt; &lt;int&gt; ## 1 audi 18 ## 2 chevrolet 19 ## 3 dodge 37 ## 4 ford 25 ## 5 honda 9 ## 6 hyundai 14 ## 7 jeep 8 ## 8 land rover 4 ## 9 lincoln 3 ## 10 mercury 4 ## 11 nissan 13 ## 12 pontiac 5 ## 13 subaru 14 ## 14 toyota 34 ## 15 volkswagen 27 It does this by calling group_by(), n() and then ungroup(). You can also perform a ‘weighted’ count. This means summing the actual values of the variable. The first argument is how it will group and the wt is what values will be summed to give you n. You cannot assign wt to character and factor columns. mpg %&gt;% count(manufacturer, wt = displ) ## # A tibble: 15 x 2 ## manufacturer n ## &lt;chr&gt; &lt;dbl&gt; ## 1 audi 45.8 ## 2 chevrolet 96.2 ## 3 dodge 162 ## 4 ford 113. ## 5 honda 15.4 ## 6 hyundai 34 ## 7 jeep 36.6 ## 8 land rover 17.2 ## 9 lincoln 16.2 ## 10 mercury 17.6 ## 11 nissan 42.5 ## 12 pontiac 19.8 ## 13 subaru 34.4 ## 14 toyota 100. ## 15 volkswagen 60.9 tally() is similar to count but does not perform group_by() first. This will give you the total number of rows in the dataframe: mpg %&gt;% tally() ## # A tibble: 1 x 1 ## n ## &lt;int&gt; ## 1 234 If you wanted the row count per group, you need to group_by() first. This will give an error: mpg %&gt;% tally(manufacturer) ## Error in sum(~manufacturer, na.rm = TRUE): invalid &#39;type&#39; (character) of argument What tally() does when you give it a column name is perform a ‘weighted tally’ which just means that it will sum up all the values in that column. It could not do that for manufacturer as this is a charater column. If you gave it a numeric column instead, it will give you the sum of all the rows of that column. mpg %&gt;% tally(displ) ## # A tibble: 1 x 1 ## n ## &lt;dbl&gt; ## 1 812. If you wanted the sum per group, you need to group_by() first. 4.3.8 group_by This function groups rows according to one or more variable(s). There are no ‘visible’ effects of this. The output is a ‘grouped tibble’. Use ungroup() to ungroup. Useful when used with summarise(): mpg %&gt;% group_by(manufacturer) %&gt;% summarise(meanDispl = mean(displ)) ## # A tibble: 15 x 2 ## manufacturer meanDispl ## &lt;chr&gt; &lt;dbl&gt; ## 1 audi 2.54 ## 2 chevrolet 5.06 ## 3 dodge 4.38 ## 4 ford 4.54 ## 5 honda 1.71 ## 6 hyundai 2.43 ## 7 jeep 4.58 ## 8 land rover 4.3 ## 9 lincoln 5.4 ## 10 mercury 4.4 ## 11 nissan 3.27 ## 12 pontiac 3.96 ## 13 subaru 2.46 ## 14 toyota 2.95 ## 15 volkswagen 2.26 There are a few things too note: The resulting tibble has the same number of rows as there are groups The only columns that remain are the column(s) that were used to group and the summarise columns. You can group by several columns: mpg %&gt;% group_by(manufacturer, year) %&gt;% summarise(meanDispl = mean(displ)) ## # A tibble: 30 x 3 ## # Groups: manufacturer [15] ## manufacturer year meanDispl ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 audi 1999 2.36 ## 2 audi 2008 2.73 ## 3 chevrolet 1999 4.97 ## 4 chevrolet 2008 5.12 ## 5 dodge 1999 4.32 ## 6 dodge 2008 4.42 ## 7 ford 1999 4.45 ## 8 ford 2008 4.66 ## 9 honda 1999 1.6 ## 10 honda 2008 1.85 ## # … with 20 more rows It is important to note that summarise() will peel away one layer of ‘grouping’. E.g. if you have group_by(var1, var2) %&gt;% summarise() The resulting tibble will be grouping by ‘var1’ because summarise() peeled away the ‘var2’ grouping. 4.3.8.1 do do() is used to perform ‘arbitrary computation’. The output will be a dataframe with the first columns being the labels and the results stored as a dataframe or a list (e.g. if you are making plots). It: * always returns a dataframe * requires the specification of . to refer to the data * was conceived to be used with group_by() to compute operations within groups This gives you the head() of the whole dataframe: mpg %&gt;% group_by(manufacturer) %&gt;% head() ## # A tibble: 6 x 11 ## # Groups: manufacturer [1] ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manua… f 21 29 p comp… ## 3 audi a4 2 2008 4 manua… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto(… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto(… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manua… f 18 26 p comp… Adding the . gives you the head() of each group: mpg %&gt;% group_by(manufacturer) %&gt;% do(head(.)) ## # A tibble: 82 x 11 ## # Groups: manufacturer [15] ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 chevrolet c150… 5.3 2008 8 auto… r 14 20 r suv ## 8 chevrolet c150… 5.3 2008 8 auto… r 11 15 e suv ## 9 chevrolet c150… 5.3 2008 8 auto… r 14 20 r suv ## 10 chevrolet c150… 5.7 1999 8 auto… r 13 17 r suv ## # … with 72 more rows 4.3.8.2 Dots The dot . refers to the data being piped in. When used with group_by() it will sometimes refer to all the data and sometimes refer to the grouped data. For example, this works well: mpg %&gt;% group_by(manufacturer) %&gt;% summarise(col = mean(year)) ## # A tibble: 15 x 2 ## manufacturer col ## &lt;chr&gt; &lt;dbl&gt; ## 1 audi 2004. ## 2 chevrolet 2005. ## 3 dodge 2004. ## 4 ford 2003. ## 5 honda 2003 ## 6 hyundai 2004. ## 7 jeep 2006. ## 8 land rover 2004. ## 9 lincoln 2002 ## 10 mercury 2004. ## 11 nissan 2004. ## 12 pontiac 2003. ## 13 subaru 2004. ## 14 toyota 2003. ## 15 volkswagen 2003. However, mpg %&gt;% group_by(manufacturer) %&gt;% summarise(col = mean(.$year)) ## # A tibble: 15 x 2 ## manufacturer col ## &lt;chr&gt; &lt;dbl&gt; ## 1 audi 2004. ## 2 chevrolet 2004. ## 3 dodge 2004. ## 4 ford 2004. ## 5 honda 2004. ## 6 hyundai 2004. ## 7 jeep 2004. ## 8 land rover 2004. ## 9 lincoln 2004. ## 10 mercury 2004. ## 11 nissan 2004. ## 12 pontiac 2004. ## 13 subaru 2004. ## 14 toyota 2004. ## 15 volkswagen 2004. It has not respected the group_by() and gives you the mean of all rows for every group. Adding do() makes it respect the group_by(): mpg %&gt;% group_by(manufacturer) %&gt;% do(summarise(. , col = mean(.$year))) ## # A tibble: 15 x 2 ## # Groups: manufacturer [15] ## manufacturer col ## &lt;chr&gt; &lt;dbl&gt; ## 1 audi 2004. ## 2 chevrolet 2005. ## 3 dodge 2004. ## 4 ford 2003. ## 5 honda 2003 ## 6 hyundai 2004. ## 7 jeep 2006. ## 8 land rover 2004. ## 9 lincoln 2002 ## 10 mercury 2004. ## 11 nissan 2004. ## 12 pontiac 2003. ## 13 subaru 2004. ## 14 toyota 2003. ## 15 volkswagen 2003. Note that you must add . as the first argument of summarise! When using the . with group_by() and mutate_at()/mutate() or summarise_at()/summarise(), the grouping is respected! See this SO question for more details. If you write your own function and add it to the chain after group_by(), use do(), otherwise the whole dataframe will be sent through. This might be because only functions specifically written to respect group_by() will do so (e.g. mutate() and summarise()). Explanation from the %&gt;% help file: (The lhs and rhs notation refers to: lhs %&gt;% rhs) Placing lhs elsewhere in rhs call - Often you will want lhs to the rhs call at another position than the first. For this purpose you can use the dot (.) as placeholder. For example, y %&gt;% f(x, .) is equivalent to f(x, y) and z %&gt;% f(x, y, arg = .) is equivalent to f(x, y, arg = z). Using the dot for secondary purposes - Often, some attribute or property of lhs is desired in the rhs call in addition to the value of lhs itself, e.g. the number of rows or columns. It is perfectly valid to use the dot placeholder several times in the rhs call, but by design the behavior is slightly different when using it inside nested function calls. In particular, if the placeholder is only used in a nested function call, lhs will also be placed as the first argument! The reason for this is that in most use-cases this produces the most readable code. For example, iris %&gt;% subset(1:nrow(.) %% 2 == 0) is equivalent to iris %&gt;% subset(., 1:nrow(.) %% 2 == 0) but slightly more compact. It is possible to overrule this behavior by enclosing the rhs in braces. For example, 1:10 %&gt;% {c(min(.), max(.))} is equivalent to c(min(1:10), max(1:10)). (See this SO question for more details) 4.3.9 n_distinct Gives you the number of distinct rows. It is a ‘faster and more concise equivalent of length(unique(x)’. 4.3.10 _at(), _all(), _if() {###at-all-if} The functions mutate(), summarise(), filter(), group_by(), select() and some others, all have _at() and _all() versions. Useful references: Tidyverse documentation Sizan Baert’s blog The dataset iris will be used as it is good for demonstrating these functions. 4.3.10.1 mutate {####mutate_ext} mutate_at() is used to perform a function on several columns at once. The syntax goes like this: Tell it which columns you want to ‘transform’. You can use c(&quot;col&quot;, &quot;col2&quot;) and refer to column names as strings OR use vars() to select columns. vars() understands the same specifications as select() e.g. -c(col), starts_with(), contains(). There is NO need to quote column names within vars() as ‘these arguments are automatically quoted and later evaluated in the context of the data frame’ - see non-standard evaluation and vars for more information. Tell it the function you want to perform. When you only want to perform one function, it will perform the function ‘in place’: iris %&gt;% mutate_at(vars(starts_with(&quot;Petal&quot;)), log) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 0.3364722 -1.6094379 setosa ## 2 4.9 3.0 0.3364722 -1.6094379 setosa ## 3 4.7 3.2 0.2623643 -1.6094379 setosa ## 4 4.6 3.1 0.4054651 -1.6094379 setosa ## 5 5.0 3.6 0.3364722 -1.6094379 setosa ## 6 5.4 3.9 0.5306283 -0.9162907 setosa Here the columns Petal.Length and Petal.Width are now logs of the old columns. If instead you wanted to add new columns to the end, use funs(): iris %&gt;% mutate_at(vars(starts_with(&quot;Petal&quot;)), funs(log = log(.))) %&gt;% head() ## Warning: funs() is soft deprecated as of dplyr 0.8.0 ## please use list() instead ## ## # Before: ## funs(name = f(.) ## ## # After: ## list(name = ~f(.)) ## This warning is displayed once per session. ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## Petal.Length_log Petal.Width_log ## 1 0.3364722 -1.6094379 ## 2 0.3364722 -1.6094379 ## 3 0.2623643 -1.6094379 ## 4 0.4054651 -1.6094379 ## 5 0.3364722 -1.6094379 ## 6 0.5306283 -0.9162907 Note that we now need to use the . notation within funs(). The dot is a placeholder and refers to the columns selected using vars(). Using funs() you can also perform several functions: iris %&gt;% mutate_at(vars(&quot;Petal.Width&quot;), funs( norm = ./mean(.), log = log(.) )) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species norm ## 1 5.1 3.5 1.4 0.2 setosa 0.1667593 ## 2 4.9 3.0 1.4 0.2 setosa 0.1667593 ## 3 4.7 3.2 1.3 0.2 setosa 0.1667593 ## 4 4.6 3.1 1.5 0.2 setosa 0.1667593 ## 5 5.0 3.6 1.4 0.2 setosa 0.1667593 ## 6 5.4 3.9 1.7 0.4 setosa 0.3335186 ## log ## 1 -1.6094379 ## 2 -1.6094379 ## 3 -1.6094379 ## 4 -1.6094379 ## 5 -1.6094379 ## 6 -0.9162907 A complex example involves dividing the selected columns by the median of just the rows (of the selected column) of the Species ’setosa`. iris %&gt;% mutate_at(vars(starts_with(&quot;Sepal&quot;)), funs(./median(.[Species == &quot;setosa&quot;]))) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 1.02 1.0294118 1.4 0.2 setosa ## 2 0.98 0.8823529 1.4 0.2 setosa ## 3 0.94 0.9411765 1.3 0.2 setosa ## 4 0.92 0.9117647 1.5 0.2 setosa ## 5 1.00 1.0588235 1.4 0.2 setosa ## 6 1.08 1.1470588 1.7 0.4 setosa The above function demonstrates the meaning of the . well. Notice the error that we get if we were to use $ instead: iris %&gt;% mutate_at(vars(starts_with(&quot;Sepal&quot;)), funs(./median(.$Species == &quot;setosa&quot;))) %&gt;% head() ## Error in Sepal.Length$Species: $ operator is invalid for atomic vectors This error says that the . is an atomic vector. This means the . is referring to one ‘selected’ columm at a time and that selected column is in the form of an atomic vector and NOT a data frame/tibble. mutate_if() - lets you select columns using a condition. Syntax is: mutate_if(.tbl, .predicate, .funs, ...) It is useful for converting all column of one data type to another data type: iris %&gt;% mutate_if(is.character, as.factor) %&gt;% str() ## &#39;data.frame&#39;: 150 obs. of 5 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... ## $ Species : Factor w/ 3 levels &quot;setosa&quot;,&quot;versicolor&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... This has converted the Species column from character to factor. If you have a more complicated function to determine which column(s) to mutate, you can: Wrap the function in an anonymous function. An anonymous function is just one that you have not given a name to (see Advanced R. iris %&gt;% select(-Species) %&gt;% mutate_if(function(x) max(x) &gt; 3, log) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 1.629241 1.2527630 0.33647224 0.2 ## 2 1.589235 1.0986123 0.33647224 0.2 ## 3 1.547563 1.1631508 0.26236426 0.2 ## 4 1.526056 1.1314021 0.40546511 0.2 ## 5 1.609438 1.2809338 0.33647224 0.2 ## 6 1.686399 1.3609766 0.53062825 0.4 ## 7 1.526056 1.2237754 0.33647224 0.3 ## 8 1.609438 1.2237754 0.40546511 0.2 ## 9 1.481605 1.0647107 0.33647224 0.2 ## 10 1.589235 1.1314021 0.40546511 0.1 ## 11 1.686399 1.3083328 0.40546511 0.2 ## 12 1.568616 1.2237754 0.47000363 0.2 ## 13 1.568616 1.0986123 0.33647224 0.1 ## 14 1.458615 1.0986123 0.09531018 0.1 ## 15 1.757858 1.3862944 0.18232156 0.2 ## 16 1.740466 1.4816045 0.40546511 0.4 ## 17 1.686399 1.3609766 0.26236426 0.4 ## 18 1.629241 1.2527630 0.33647224 0.3 ## 19 1.740466 1.3350011 0.53062825 0.3 ## 20 1.629241 1.3350011 0.40546511 0.3 ## 21 1.686399 1.2237754 0.53062825 0.2 ## 22 1.629241 1.3083328 0.40546511 0.4 ## 23 1.526056 1.2809338 0.00000000 0.2 ## 24 1.629241 1.1939225 0.53062825 0.5 ## 25 1.568616 1.2237754 0.64185389 0.2 ## 26 1.609438 1.0986123 0.47000363 0.2 ## 27 1.609438 1.2237754 0.47000363 0.4 ## 28 1.648659 1.2527630 0.40546511 0.2 ## 29 1.648659 1.2237754 0.33647224 0.2 ## 30 1.547563 1.1631508 0.47000363 0.2 ## 31 1.568616 1.1314021 0.47000363 0.2 ## 32 1.686399 1.2237754 0.40546511 0.4 ## 33 1.648659 1.4109870 0.40546511 0.1 ## 34 1.704748 1.4350845 0.33647224 0.2 ## 35 1.589235 1.1314021 0.40546511 0.2 ## 36 1.609438 1.1631508 0.18232156 0.2 ## 37 1.704748 1.2527630 0.26236426 0.2 ## 38 1.589235 1.2809338 0.33647224 0.1 ## 39 1.481605 1.0986123 0.26236426 0.2 ## 40 1.629241 1.2237754 0.40546511 0.2 ## 41 1.609438 1.2527630 0.26236426 0.3 ## 42 1.504077 0.8329091 0.26236426 0.3 ## 43 1.481605 1.1631508 0.26236426 0.2 ## 44 1.609438 1.2527630 0.47000363 0.6 ## 45 1.629241 1.3350011 0.64185389 0.4 ## 46 1.568616 1.0986123 0.33647224 0.3 ## 47 1.629241 1.3350011 0.47000363 0.2 ## 48 1.526056 1.1631508 0.33647224 0.2 ## 49 1.667707 1.3083328 0.40546511 0.2 ## 50 1.609438 1.1939225 0.33647224 0.2 ## 51 1.945910 1.1631508 1.54756251 1.4 ## 52 1.856298 1.1631508 1.50407740 1.5 ## 53 1.931521 1.1314021 1.58923521 1.5 ## 54 1.704748 0.8329091 1.38629436 1.3 ## 55 1.871802 1.0296194 1.52605630 1.5 ## 56 1.740466 1.0296194 1.50407740 1.3 ## 57 1.840550 1.1939225 1.54756251 1.6 ## 58 1.589235 0.8754687 1.19392247 1.0 ## 59 1.887070 1.0647107 1.52605630 1.3 ## 60 1.648659 0.9932518 1.36097655 1.4 ## 61 1.609438 0.6931472 1.25276297 1.0 ## 62 1.774952 1.0986123 1.43508453 1.5 ## 63 1.791759 0.7884574 1.38629436 1.0 ## 64 1.808289 1.0647107 1.54756251 1.4 ## 65 1.722767 1.0647107 1.28093385 1.3 ## 66 1.902108 1.1314021 1.48160454 1.4 ## 67 1.722767 1.0986123 1.50407740 1.5 ## 68 1.757858 0.9932518 1.41098697 1.0 ## 69 1.824549 0.7884574 1.50407740 1.5 ## 70 1.722767 0.9162907 1.36097655 1.1 ## 71 1.774952 1.1631508 1.56861592 1.8 ## 72 1.808289 1.0296194 1.38629436 1.3 ## 73 1.840550 0.9162907 1.58923521 1.5 ## 74 1.808289 1.0296194 1.54756251 1.2 ## 75 1.856298 1.0647107 1.45861502 1.3 ## 76 1.887070 1.0986123 1.48160454 1.4 ## 77 1.916923 1.0296194 1.56861592 1.4 ## 78 1.902108 1.0986123 1.60943791 1.7 ## 79 1.791759 1.0647107 1.50407740 1.5 ## 80 1.740466 0.9555114 1.25276297 1.0 ## 81 1.704748 0.8754687 1.33500107 1.1 ## 82 1.704748 0.8754687 1.30833282 1.0 ## 83 1.757858 0.9932518 1.36097655 1.2 ## 84 1.791759 0.9932518 1.62924054 1.6 ## 85 1.686399 1.0986123 1.50407740 1.5 ## 86 1.791759 1.2237754 1.50407740 1.6 ## 87 1.902108 1.1314021 1.54756251 1.5 ## 88 1.840550 0.8329091 1.48160454 1.3 ## 89 1.722767 1.0986123 1.41098697 1.3 ## 90 1.704748 0.9162907 1.38629436 1.3 ## 91 1.704748 0.9555114 1.48160454 1.2 ## 92 1.808289 1.0986123 1.52605630 1.4 ## 93 1.757858 0.9555114 1.38629436 1.2 ## 94 1.609438 0.8329091 1.19392247 1.0 ## 95 1.722767 0.9932518 1.43508453 1.3 ## 96 1.740466 1.0986123 1.43508453 1.2 ## 97 1.740466 1.0647107 1.43508453 1.3 ## 98 1.824549 1.0647107 1.45861502 1.3 ## 99 1.629241 0.9162907 1.09861229 1.1 ## 100 1.740466 1.0296194 1.41098697 1.3 ## 101 1.840550 1.1939225 1.79175947 2.5 ## 102 1.757858 0.9932518 1.62924054 1.9 ## 103 1.960095 1.0986123 1.77495235 2.1 ## 104 1.840550 1.0647107 1.72276660 1.8 ## 105 1.871802 1.0986123 1.75785792 2.2 ## 106 2.028148 1.0986123 1.88706965 2.1 ## 107 1.589235 0.9162907 1.50407740 1.7 ## 108 1.987874 1.0647107 1.84054963 1.8 ## 109 1.902108 0.9162907 1.75785792 1.8 ## 110 1.974081 1.2809338 1.80828877 2.5 ## 111 1.871802 1.1631508 1.62924054 2.0 ## 112 1.856298 0.9932518 1.66770682 1.9 ## 113 1.916923 1.0986123 1.70474809 2.1 ## 114 1.740466 0.9162907 1.60943791 2.0 ## 115 1.757858 1.0296194 1.62924054 2.4 ## 116 1.856298 1.1631508 1.66770682 2.3 ## 117 1.871802 1.0986123 1.70474809 1.8 ## 118 2.041220 1.3350011 1.90210753 2.2 ## 119 2.041220 0.9555114 1.93152141 2.3 ## 120 1.791759 0.7884574 1.60943791 1.5 ## 121 1.931521 1.1631508 1.74046617 2.3 ## 122 1.722767 1.0296194 1.58923521 2.0 ## 123 2.041220 1.0296194 1.90210753 2.0 ## 124 1.840550 0.9932518 1.58923521 1.8 ## 125 1.902108 1.1939225 1.74046617 2.1 ## 126 1.974081 1.1631508 1.79175947 1.8 ## 127 1.824549 1.0296194 1.56861592 1.8 ## 128 1.808289 1.0986123 1.58923521 1.8 ## 129 1.856298 1.0296194 1.72276660 2.1 ## 130 1.974081 1.0986123 1.75785792 1.6 ## 131 2.001480 1.0296194 1.80828877 1.9 ## 132 2.066863 1.3350011 1.85629799 2.0 ## 133 1.856298 1.0296194 1.72276660 2.2 ## 134 1.840550 1.0296194 1.62924054 1.5 ## 135 1.808289 0.9555114 1.72276660 1.4 ## 136 2.041220 1.0986123 1.80828877 2.3 ## 137 1.840550 1.2237754 1.72276660 2.4 ## 138 1.856298 1.1314021 1.70474809 1.8 ## 139 1.791759 1.0986123 1.56861592 1.8 ## 140 1.931521 1.1314021 1.68639895 2.1 ## 141 1.902108 1.1314021 1.72276660 2.4 ## 142 1.931521 1.1314021 1.62924054 2.3 ## 143 1.757858 0.9932518 1.62924054 1.9 ## 144 1.916923 1.1631508 1.77495235 2.3 ## 145 1.902108 1.1939225 1.74046617 2.5 ## 146 1.902108 1.0986123 1.64865863 2.3 ## 147 1.840550 0.9162907 1.60943791 1.9 ## 148 1.871802 1.0986123 1.64865863 2.0 ## 149 1.824549 1.2237754 1.68639895 2.3 ## 150 1.774952 1.0986123 1.62924054 1.8 Use the tilde ~ which does the same thing ( ref: SO). iris %&gt;% select(-Species) %&gt;% mutate_if( ~ max(.) &gt; 3, log) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 1.629241 1.2527630 0.33647224 0.2 ## 2 1.589235 1.0986123 0.33647224 0.2 ## 3 1.547563 1.1631508 0.26236426 0.2 ## 4 1.526056 1.1314021 0.40546511 0.2 ## 5 1.609438 1.2809338 0.33647224 0.2 ## 6 1.686399 1.3609766 0.53062825 0.4 ## 7 1.526056 1.2237754 0.33647224 0.3 ## 8 1.609438 1.2237754 0.40546511 0.2 ## 9 1.481605 1.0647107 0.33647224 0.2 ## 10 1.589235 1.1314021 0.40546511 0.1 ## 11 1.686399 1.3083328 0.40546511 0.2 ## 12 1.568616 1.2237754 0.47000363 0.2 ## 13 1.568616 1.0986123 0.33647224 0.1 ## 14 1.458615 1.0986123 0.09531018 0.1 ## 15 1.757858 1.3862944 0.18232156 0.2 ## 16 1.740466 1.4816045 0.40546511 0.4 ## 17 1.686399 1.3609766 0.26236426 0.4 ## 18 1.629241 1.2527630 0.33647224 0.3 ## 19 1.740466 1.3350011 0.53062825 0.3 ## 20 1.629241 1.3350011 0.40546511 0.3 ## 21 1.686399 1.2237754 0.53062825 0.2 ## 22 1.629241 1.3083328 0.40546511 0.4 ## 23 1.526056 1.2809338 0.00000000 0.2 ## 24 1.629241 1.1939225 0.53062825 0.5 ## 25 1.568616 1.2237754 0.64185389 0.2 ## 26 1.609438 1.0986123 0.47000363 0.2 ## 27 1.609438 1.2237754 0.47000363 0.4 ## 28 1.648659 1.2527630 0.40546511 0.2 ## 29 1.648659 1.2237754 0.33647224 0.2 ## 30 1.547563 1.1631508 0.47000363 0.2 ## 31 1.568616 1.1314021 0.47000363 0.2 ## 32 1.686399 1.2237754 0.40546511 0.4 ## 33 1.648659 1.4109870 0.40546511 0.1 ## 34 1.704748 1.4350845 0.33647224 0.2 ## 35 1.589235 1.1314021 0.40546511 0.2 ## 36 1.609438 1.1631508 0.18232156 0.2 ## 37 1.704748 1.2527630 0.26236426 0.2 ## 38 1.589235 1.2809338 0.33647224 0.1 ## 39 1.481605 1.0986123 0.26236426 0.2 ## 40 1.629241 1.2237754 0.40546511 0.2 ## 41 1.609438 1.2527630 0.26236426 0.3 ## 42 1.504077 0.8329091 0.26236426 0.3 ## 43 1.481605 1.1631508 0.26236426 0.2 ## 44 1.609438 1.2527630 0.47000363 0.6 ## 45 1.629241 1.3350011 0.64185389 0.4 ## 46 1.568616 1.0986123 0.33647224 0.3 ## 47 1.629241 1.3350011 0.47000363 0.2 ## 48 1.526056 1.1631508 0.33647224 0.2 ## 49 1.667707 1.3083328 0.40546511 0.2 ## 50 1.609438 1.1939225 0.33647224 0.2 ## 51 1.945910 1.1631508 1.54756251 1.4 ## 52 1.856298 1.1631508 1.50407740 1.5 ## 53 1.931521 1.1314021 1.58923521 1.5 ## 54 1.704748 0.8329091 1.38629436 1.3 ## 55 1.871802 1.0296194 1.52605630 1.5 ## 56 1.740466 1.0296194 1.50407740 1.3 ## 57 1.840550 1.1939225 1.54756251 1.6 ## 58 1.589235 0.8754687 1.19392247 1.0 ## 59 1.887070 1.0647107 1.52605630 1.3 ## 60 1.648659 0.9932518 1.36097655 1.4 ## 61 1.609438 0.6931472 1.25276297 1.0 ## 62 1.774952 1.0986123 1.43508453 1.5 ## 63 1.791759 0.7884574 1.38629436 1.0 ## 64 1.808289 1.0647107 1.54756251 1.4 ## 65 1.722767 1.0647107 1.28093385 1.3 ## 66 1.902108 1.1314021 1.48160454 1.4 ## 67 1.722767 1.0986123 1.50407740 1.5 ## 68 1.757858 0.9932518 1.41098697 1.0 ## 69 1.824549 0.7884574 1.50407740 1.5 ## 70 1.722767 0.9162907 1.36097655 1.1 ## 71 1.774952 1.1631508 1.56861592 1.8 ## 72 1.808289 1.0296194 1.38629436 1.3 ## 73 1.840550 0.9162907 1.58923521 1.5 ## 74 1.808289 1.0296194 1.54756251 1.2 ## 75 1.856298 1.0647107 1.45861502 1.3 ## 76 1.887070 1.0986123 1.48160454 1.4 ## 77 1.916923 1.0296194 1.56861592 1.4 ## 78 1.902108 1.0986123 1.60943791 1.7 ## 79 1.791759 1.0647107 1.50407740 1.5 ## 80 1.740466 0.9555114 1.25276297 1.0 ## 81 1.704748 0.8754687 1.33500107 1.1 ## 82 1.704748 0.8754687 1.30833282 1.0 ## 83 1.757858 0.9932518 1.36097655 1.2 ## 84 1.791759 0.9932518 1.62924054 1.6 ## 85 1.686399 1.0986123 1.50407740 1.5 ## 86 1.791759 1.2237754 1.50407740 1.6 ## 87 1.902108 1.1314021 1.54756251 1.5 ## 88 1.840550 0.8329091 1.48160454 1.3 ## 89 1.722767 1.0986123 1.41098697 1.3 ## 90 1.704748 0.9162907 1.38629436 1.3 ## 91 1.704748 0.9555114 1.48160454 1.2 ## 92 1.808289 1.0986123 1.52605630 1.4 ## 93 1.757858 0.9555114 1.38629436 1.2 ## 94 1.609438 0.8329091 1.19392247 1.0 ## 95 1.722767 0.9932518 1.43508453 1.3 ## 96 1.740466 1.0986123 1.43508453 1.2 ## 97 1.740466 1.0647107 1.43508453 1.3 ## 98 1.824549 1.0647107 1.45861502 1.3 ## 99 1.629241 0.9162907 1.09861229 1.1 ## 100 1.740466 1.0296194 1.41098697 1.3 ## 101 1.840550 1.1939225 1.79175947 2.5 ## 102 1.757858 0.9932518 1.62924054 1.9 ## 103 1.960095 1.0986123 1.77495235 2.1 ## 104 1.840550 1.0647107 1.72276660 1.8 ## 105 1.871802 1.0986123 1.75785792 2.2 ## 106 2.028148 1.0986123 1.88706965 2.1 ## 107 1.589235 0.9162907 1.50407740 1.7 ## 108 1.987874 1.0647107 1.84054963 1.8 ## 109 1.902108 0.9162907 1.75785792 1.8 ## 110 1.974081 1.2809338 1.80828877 2.5 ## 111 1.871802 1.1631508 1.62924054 2.0 ## 112 1.856298 0.9932518 1.66770682 1.9 ## 113 1.916923 1.0986123 1.70474809 2.1 ## 114 1.740466 0.9162907 1.60943791 2.0 ## 115 1.757858 1.0296194 1.62924054 2.4 ## 116 1.856298 1.1631508 1.66770682 2.3 ## 117 1.871802 1.0986123 1.70474809 1.8 ## 118 2.041220 1.3350011 1.90210753 2.2 ## 119 2.041220 0.9555114 1.93152141 2.3 ## 120 1.791759 0.7884574 1.60943791 1.5 ## 121 1.931521 1.1631508 1.74046617 2.3 ## 122 1.722767 1.0296194 1.58923521 2.0 ## 123 2.041220 1.0296194 1.90210753 2.0 ## 124 1.840550 0.9932518 1.58923521 1.8 ## 125 1.902108 1.1939225 1.74046617 2.1 ## 126 1.974081 1.1631508 1.79175947 1.8 ## 127 1.824549 1.0296194 1.56861592 1.8 ## 128 1.808289 1.0986123 1.58923521 1.8 ## 129 1.856298 1.0296194 1.72276660 2.1 ## 130 1.974081 1.0986123 1.75785792 1.6 ## 131 2.001480 1.0296194 1.80828877 1.9 ## 132 2.066863 1.3350011 1.85629799 2.0 ## 133 1.856298 1.0296194 1.72276660 2.2 ## 134 1.840550 1.0296194 1.62924054 1.5 ## 135 1.808289 0.9555114 1.72276660 1.4 ## 136 2.041220 1.0986123 1.80828877 2.3 ## 137 1.840550 1.2237754 1.72276660 2.4 ## 138 1.856298 1.1314021 1.70474809 1.8 ## 139 1.791759 1.0986123 1.56861592 1.8 ## 140 1.931521 1.1314021 1.68639895 2.1 ## 141 1.902108 1.1314021 1.72276660 2.4 ## 142 1.931521 1.1314021 1.62924054 2.3 ## 143 1.757858 0.9932518 1.62924054 1.9 ## 144 1.916923 1.1631508 1.77495235 2.3 ## 145 1.902108 1.1939225 1.74046617 2.5 ## 146 1.902108 1.0986123 1.64865863 2.3 ## 147 1.840550 0.9162907 1.60943791 1.9 ## 148 1.871802 1.0986123 1.64865863 2.0 ## 149 1.824549 1.2237754 1.68639895 2.3 ## 150 1.774952 1.0986123 1.62924054 1.8 Note that the .predicate argument is passed to rlang::as_function(), which is why you can use the function name only without brackets at the end and apparently ‘strings representing function names’. In the above example, the columns we are selecting are ones where the max value is greater than 3. The function we are performing is log(). If you want to test multiple conditions, I suggest you write your own function: testfun &lt;- function(x){ max(x)&gt;3 &amp; min(x) &gt; 1 } iris %&gt;% select(-Species) %&gt;% mutate_if(testfun, log) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 1.629241 1.252763 1.4 0.2 ## 2 1.589235 1.098612 1.4 0.2 ## 3 1.547563 1.163151 1.3 0.2 ## 4 1.526056 1.131402 1.5 0.2 ## 5 1.609438 1.280934 1.4 0.2 ## 6 1.686399 1.360977 1.7 0.4 You can also test several functions within the mutate_if() using the two syntax described above: iris %&gt;% select(-Species) %&gt;% mutate_if(function(x) is.double(x) &amp; is.numeric(x), log) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 1.629241 1.2527630 0.33647224 -1.60943791 ## 2 1.589235 1.0986123 0.33647224 -1.60943791 ## 3 1.547563 1.1631508 0.26236426 -1.60943791 ## 4 1.526056 1.1314021 0.40546511 -1.60943791 ## 5 1.609438 1.2809338 0.33647224 -1.60943791 ## 6 1.686399 1.3609766 0.53062825 -0.91629073 ## 7 1.526056 1.2237754 0.33647224 -1.20397280 ## 8 1.609438 1.2237754 0.40546511 -1.60943791 ## 9 1.481605 1.0647107 0.33647224 -1.60943791 ## 10 1.589235 1.1314021 0.40546511 -2.30258509 ## 11 1.686399 1.3083328 0.40546511 -1.60943791 ## 12 1.568616 1.2237754 0.47000363 -1.60943791 ## 13 1.568616 1.0986123 0.33647224 -2.30258509 ## 14 1.458615 1.0986123 0.09531018 -2.30258509 ## 15 1.757858 1.3862944 0.18232156 -1.60943791 ## 16 1.740466 1.4816045 0.40546511 -0.91629073 ## 17 1.686399 1.3609766 0.26236426 -0.91629073 ## 18 1.629241 1.2527630 0.33647224 -1.20397280 ## 19 1.740466 1.3350011 0.53062825 -1.20397280 ## 20 1.629241 1.3350011 0.40546511 -1.20397280 ## 21 1.686399 1.2237754 0.53062825 -1.60943791 ## 22 1.629241 1.3083328 0.40546511 -0.91629073 ## 23 1.526056 1.2809338 0.00000000 -1.60943791 ## 24 1.629241 1.1939225 0.53062825 -0.69314718 ## 25 1.568616 1.2237754 0.64185389 -1.60943791 ## 26 1.609438 1.0986123 0.47000363 -1.60943791 ## 27 1.609438 1.2237754 0.47000363 -0.91629073 ## 28 1.648659 1.2527630 0.40546511 -1.60943791 ## 29 1.648659 1.2237754 0.33647224 -1.60943791 ## 30 1.547563 1.1631508 0.47000363 -1.60943791 ## 31 1.568616 1.1314021 0.47000363 -1.60943791 ## 32 1.686399 1.2237754 0.40546511 -0.91629073 ## 33 1.648659 1.4109870 0.40546511 -2.30258509 ## 34 1.704748 1.4350845 0.33647224 -1.60943791 ## 35 1.589235 1.1314021 0.40546511 -1.60943791 ## 36 1.609438 1.1631508 0.18232156 -1.60943791 ## 37 1.704748 1.2527630 0.26236426 -1.60943791 ## 38 1.589235 1.2809338 0.33647224 -2.30258509 ## 39 1.481605 1.0986123 0.26236426 -1.60943791 ## 40 1.629241 1.2237754 0.40546511 -1.60943791 ## 41 1.609438 1.2527630 0.26236426 -1.20397280 ## 42 1.504077 0.8329091 0.26236426 -1.20397280 ## 43 1.481605 1.1631508 0.26236426 -1.60943791 ## 44 1.609438 1.2527630 0.47000363 -0.51082562 ## 45 1.629241 1.3350011 0.64185389 -0.91629073 ## 46 1.568616 1.0986123 0.33647224 -1.20397280 ## 47 1.629241 1.3350011 0.47000363 -1.60943791 ## 48 1.526056 1.1631508 0.33647224 -1.60943791 ## 49 1.667707 1.3083328 0.40546511 -1.60943791 ## 50 1.609438 1.1939225 0.33647224 -1.60943791 ## 51 1.945910 1.1631508 1.54756251 0.33647224 ## 52 1.856298 1.1631508 1.50407740 0.40546511 ## 53 1.931521 1.1314021 1.58923521 0.40546511 ## 54 1.704748 0.8329091 1.38629436 0.26236426 ## 55 1.871802 1.0296194 1.52605630 0.40546511 ## 56 1.740466 1.0296194 1.50407740 0.26236426 ## 57 1.840550 1.1939225 1.54756251 0.47000363 ## 58 1.589235 0.8754687 1.19392247 0.00000000 ## 59 1.887070 1.0647107 1.52605630 0.26236426 ## 60 1.648659 0.9932518 1.36097655 0.33647224 ## 61 1.609438 0.6931472 1.25276297 0.00000000 ## 62 1.774952 1.0986123 1.43508453 0.40546511 ## 63 1.791759 0.7884574 1.38629436 0.00000000 ## 64 1.808289 1.0647107 1.54756251 0.33647224 ## 65 1.722767 1.0647107 1.28093385 0.26236426 ## 66 1.902108 1.1314021 1.48160454 0.33647224 ## 67 1.722767 1.0986123 1.50407740 0.40546511 ## 68 1.757858 0.9932518 1.41098697 0.00000000 ## 69 1.824549 0.7884574 1.50407740 0.40546511 ## 70 1.722767 0.9162907 1.36097655 0.09531018 ## 71 1.774952 1.1631508 1.56861592 0.58778666 ## 72 1.808289 1.0296194 1.38629436 0.26236426 ## 73 1.840550 0.9162907 1.58923521 0.40546511 ## 74 1.808289 1.0296194 1.54756251 0.18232156 ## 75 1.856298 1.0647107 1.45861502 0.26236426 ## 76 1.887070 1.0986123 1.48160454 0.33647224 ## 77 1.916923 1.0296194 1.56861592 0.33647224 ## 78 1.902108 1.0986123 1.60943791 0.53062825 ## 79 1.791759 1.0647107 1.50407740 0.40546511 ## 80 1.740466 0.9555114 1.25276297 0.00000000 ## 81 1.704748 0.8754687 1.33500107 0.09531018 ## 82 1.704748 0.8754687 1.30833282 0.00000000 ## 83 1.757858 0.9932518 1.36097655 0.18232156 ## 84 1.791759 0.9932518 1.62924054 0.47000363 ## 85 1.686399 1.0986123 1.50407740 0.40546511 ## 86 1.791759 1.2237754 1.50407740 0.47000363 ## 87 1.902108 1.1314021 1.54756251 0.40546511 ## 88 1.840550 0.8329091 1.48160454 0.26236426 ## 89 1.722767 1.0986123 1.41098697 0.26236426 ## 90 1.704748 0.9162907 1.38629436 0.26236426 ## 91 1.704748 0.9555114 1.48160454 0.18232156 ## 92 1.808289 1.0986123 1.52605630 0.33647224 ## 93 1.757858 0.9555114 1.38629436 0.18232156 ## 94 1.609438 0.8329091 1.19392247 0.00000000 ## 95 1.722767 0.9932518 1.43508453 0.26236426 ## 96 1.740466 1.0986123 1.43508453 0.18232156 ## 97 1.740466 1.0647107 1.43508453 0.26236426 ## 98 1.824549 1.0647107 1.45861502 0.26236426 ## 99 1.629241 0.9162907 1.09861229 0.09531018 ## 100 1.740466 1.0296194 1.41098697 0.26236426 ## 101 1.840550 1.1939225 1.79175947 0.91629073 ## 102 1.757858 0.9932518 1.62924054 0.64185389 ## 103 1.960095 1.0986123 1.77495235 0.74193734 ## 104 1.840550 1.0647107 1.72276660 0.58778666 ## 105 1.871802 1.0986123 1.75785792 0.78845736 ## 106 2.028148 1.0986123 1.88706965 0.74193734 ## 107 1.589235 0.9162907 1.50407740 0.53062825 ## 108 1.987874 1.0647107 1.84054963 0.58778666 ## 109 1.902108 0.9162907 1.75785792 0.58778666 ## 110 1.974081 1.2809338 1.80828877 0.91629073 ## 111 1.871802 1.1631508 1.62924054 0.69314718 ## 112 1.856298 0.9932518 1.66770682 0.64185389 ## 113 1.916923 1.0986123 1.70474809 0.74193734 ## 114 1.740466 0.9162907 1.60943791 0.69314718 ## 115 1.757858 1.0296194 1.62924054 0.87546874 ## 116 1.856298 1.1631508 1.66770682 0.83290912 ## 117 1.871802 1.0986123 1.70474809 0.58778666 ## 118 2.041220 1.3350011 1.90210753 0.78845736 ## 119 2.041220 0.9555114 1.93152141 0.83290912 ## 120 1.791759 0.7884574 1.60943791 0.40546511 ## 121 1.931521 1.1631508 1.74046617 0.83290912 ## 122 1.722767 1.0296194 1.58923521 0.69314718 ## 123 2.041220 1.0296194 1.90210753 0.69314718 ## 124 1.840550 0.9932518 1.58923521 0.58778666 ## 125 1.902108 1.1939225 1.74046617 0.74193734 ## 126 1.974081 1.1631508 1.79175947 0.58778666 ## 127 1.824549 1.0296194 1.56861592 0.58778666 ## 128 1.808289 1.0986123 1.58923521 0.58778666 ## 129 1.856298 1.0296194 1.72276660 0.74193734 ## 130 1.974081 1.0986123 1.75785792 0.47000363 ## 131 2.001480 1.0296194 1.80828877 0.64185389 ## 132 2.066863 1.3350011 1.85629799 0.69314718 ## 133 1.856298 1.0296194 1.72276660 0.78845736 ## 134 1.840550 1.0296194 1.62924054 0.40546511 ## 135 1.808289 0.9555114 1.72276660 0.33647224 ## 136 2.041220 1.0986123 1.80828877 0.83290912 ## 137 1.840550 1.2237754 1.72276660 0.87546874 ## 138 1.856298 1.1314021 1.70474809 0.58778666 ## 139 1.791759 1.0986123 1.56861592 0.58778666 ## 140 1.931521 1.1314021 1.68639895 0.74193734 ## 141 1.902108 1.1314021 1.72276660 0.87546874 ## 142 1.931521 1.1314021 1.62924054 0.83290912 ## 143 1.757858 0.9932518 1.62924054 0.64185389 ## 144 1.916923 1.1631508 1.77495235 0.83290912 ## 145 1.902108 1.1939225 1.74046617 0.91629073 ## 146 1.902108 1.0986123 1.64865863 0.83290912 ## 147 1.840550 0.9162907 1.60943791 0.64185389 ## 148 1.871802 1.0986123 1.64865863 0.69314718 ## 149 1.824549 1.2237754 1.68639895 0.83290912 ## 150 1.774952 1.0986123 1.62924054 0.58778666 mutate_all() - here no selection of columns required. Your function will be performed on all columns. iris %&gt;% select(-Species) %&gt;% mutate_all(log) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 1.629241 1.252763 0.3364722 -1.6094379 ## 2 1.589235 1.098612 0.3364722 -1.6094379 ## 3 1.547563 1.163151 0.2623643 -1.6094379 ## 4 1.526056 1.131402 0.4054651 -1.6094379 ## 5 1.609438 1.280934 0.3364722 -1.6094379 ## 6 1.686399 1.360977 0.5306283 -0.9162907 4.3.10.2 summarise {####summarise_ext summarise_at() works similarly to mutate_at(): again, select the columns you wish to summarise using c('colname') or vars() specify the function you want performed, using funs() when you want several functions or iris %&gt;% summarise_at(vars(starts_with(&quot;Petal&quot;)), mean) ## Petal.Length Petal.Width ## 1 3.758 1.199333 Note that you can ONLY use functions which return a single length vector, as the aim of the summarise- functions is to summarise into 1 value. For example, you could not use log(): iris %&gt;% summarise_at(vars(starts_with(&quot;Petal&quot;)), log) ## Error: Column `Petal.Length` must be length 1 (a summary value), not 150 When you put the function in funs(), the names of the output columns are changed to add your column name (specified on the LHS of your function) to the end of your column name. iris %&gt;% summarise_at(vars(starts_with(&quot;Petal&quot;)), funs(mean = mean(.))) ## Petal.Length_mean Petal.Width_mean ## 1 3.758 1.199333 You can also add group_by() to the chain: iris %&gt;% group_by(Species) %&gt;% summarise_at(vars(starts_with(&quot;Petal&quot;)), funs(mean, median)) ## # A tibble: 3 x 5 ## Species Petal.Length_me… Petal.Width_mean Petal.Length_me… ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 1.46 0.246 1.5 ## 2 versic… 4.26 1.33 4.35 ## 3 virgin… 5.55 2.03 5.55 ## # … with 1 more variable: Petal.Width_median &lt;dbl&gt; Note how the function name is added to the end of each column to specify which function has been formed on each of your columns. summarise_if() - like above, select your column(s) by specifying a condition and then tell it what function you want to perform. iris %&gt;% group_by(Species) %&gt;% summarise_if(is.numeric, mean, na.rm = TRUE) ## # A tibble: 3 x 5 ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 3.43 1.46 0.246 ## 2 versicolor 5.94 2.77 4.26 1.33 ## 3 virginica 6.59 2.97 5.55 2.03 Note that you can pass arguments to your function using the final ... argument of summarise_if(). Also notice how your column names have not changed. If we use funs() AND add a LHS to the function, they will change: iris %&gt;% group_by(Species) %&gt;% summarise_if(is.numeric, funs(mean = mean(.))) ## # A tibble: 3 x 5 ## Species Sepal.Length_me… Sepal.Width_mean Petal.Length_me… ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 3.43 1.46 ## 2 versic… 5.94 2.77 4.26 ## 3 virgin… 6.59 2.97 5.55 ## # … with 1 more variable: Petal.Width_mean &lt;dbl&gt; summarise_all() - again, your function(s) are performed on all your columns. iris %&gt;% group_by(Species) %&gt;% summarise_all(mean) ## # A tibble: 3 x 5 ## Species Sepal.Length Sepal.Width Petal.Length Petal.Width ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 3.43 1.46 0.246 ## 2 versicolor 5.94 2.77 4.26 1.33 ## 3 virginica 6.59 2.97 5.55 2.03 4.3.10.3 filter {####filter_ext} filter_at() - similar to above, select the columns to filter on using c('colname') or vars(), then specify your condition. You condition must be wrapped in all_vars() or any_vars(). This is because, while filter() checks only one column to see if it meets your condition, filter_at() checks several columns. It then returns the results for every selected column. As suggested by the name all_vars() returns TRUE for a row only if the condition is met in all selected columns and any_vars() returns TRUE if the condition is met in any of the selected columns. Let’s have a look at the function in action: iris %&gt;% filter_at(vars(starts_with(&quot;Petal&quot;)), any_vars(. &gt; 2)) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 7.0 3.2 4.7 1.4 versicolor ## 2 6.4 3.2 4.5 1.5 versicolor ## 3 6.9 3.1 4.9 1.5 versicolor ## 4 5.5 2.3 4.0 1.3 versicolor ## 5 6.5 2.8 4.6 1.5 versicolor ## 6 5.7 2.8 4.5 1.3 versicolor What the above code does is check each row to see if the value in ANY of the columns starting with ‘Petal’ is creater than 2. Note how we have to use the . again. This placeholder refers to the values in each selected column, one at a time. filter_if() - like before, select the columns on which you wish to apply your filtering condition, using your column selecting condition. Then your row filtering condition will be applied to all columns that meet your column selecting condition. The functions all_vars() or any_vars() must be used to specify if the row filtering condition needs to be met in at least one column or all columns before the row is returned. An example: iris %&gt;% filter_if(is.numeric, all_vars(. &gt; 1)) %&gt;% head() ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 7.0 3.2 4.7 1.4 versicolor ## 2 6.4 3.2 4.5 1.5 versicolor ## 3 6.9 3.1 4.9 1.5 versicolor ## 4 5.5 2.3 4.0 1.3 versicolor ## 5 6.5 2.8 4.6 1.5 versicolor ## 6 5.7 2.8 4.5 1.3 versicolor Here we are filtering on all columns that are of the numeric data type. Then we want the row value to be greater than 1 in all of the chosen columns. filter_all() - as above, this uses all the columns. Thus the condition must be met in ALL columns for the row to be returned. iris %&gt;% select(-Species) %&gt;% filter_all(any_vars(. &gt; 5)) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 5.4 3.9 1.7 0.4 ## 3 5.4 3.7 1.5 0.2 ## 4 5.8 4.0 1.2 0.2 ## 5 5.7 4.4 1.5 0.4 ## 6 5.4 3.9 1.3 0.4 ## 7 5.1 3.5 1.4 0.3 ## 8 5.7 3.8 1.7 0.3 ## 9 5.1 3.8 1.5 0.3 ## 10 5.4 3.4 1.7 0.2 ## 11 5.1 3.7 1.5 0.4 ## 12 5.1 3.3 1.7 0.5 ## 13 5.2 3.5 1.5 0.2 ## 14 5.2 3.4 1.4 0.2 ## 15 5.4 3.4 1.5 0.4 ## 16 5.2 4.1 1.5 0.1 ## 17 5.5 4.2 1.4 0.2 ## 18 5.5 3.5 1.3 0.2 ## 19 5.1 3.4 1.5 0.2 ## 20 5.1 3.8 1.9 0.4 ## 21 5.1 3.8 1.6 0.2 ## 22 5.3 3.7 1.5 0.2 ## 23 7.0 3.2 4.7 1.4 ## 24 6.4 3.2 4.5 1.5 ## 25 6.9 3.1 4.9 1.5 ## 26 5.5 2.3 4.0 1.3 ## 27 6.5 2.8 4.6 1.5 ## 28 5.7 2.8 4.5 1.3 ## 29 6.3 3.3 4.7 1.6 ## 30 6.6 2.9 4.6 1.3 ## 31 5.2 2.7 3.9 1.4 ## 32 5.9 3.0 4.2 1.5 ## 33 6.0 2.2 4.0 1.0 ## 34 6.1 2.9 4.7 1.4 ## 35 5.6 2.9 3.6 1.3 ## 36 6.7 3.1 4.4 1.4 ## 37 5.6 3.0 4.5 1.5 ## 38 5.8 2.7 4.1 1.0 ## 39 6.2 2.2 4.5 1.5 ## 40 5.6 2.5 3.9 1.1 ## 41 5.9 3.2 4.8 1.8 ## 42 6.1 2.8 4.0 1.3 ## 43 6.3 2.5 4.9 1.5 ## 44 6.1 2.8 4.7 1.2 ## 45 6.4 2.9 4.3 1.3 ## 46 6.6 3.0 4.4 1.4 ## 47 6.8 2.8 4.8 1.4 ## 48 6.7 3.0 5.0 1.7 ## 49 6.0 2.9 4.5 1.5 ## 50 5.7 2.6 3.5 1.0 ## 51 5.5 2.4 3.8 1.1 ## 52 5.5 2.4 3.7 1.0 ## 53 5.8 2.7 3.9 1.2 ## 54 6.0 2.7 5.1 1.6 ## 55 5.4 3.0 4.5 1.5 ## 56 6.0 3.4 4.5 1.6 ## 57 6.7 3.1 4.7 1.5 ## 58 6.3 2.3 4.4 1.3 ## 59 5.6 3.0 4.1 1.3 ## 60 5.5 2.5 4.0 1.3 ## 61 5.5 2.6 4.4 1.2 ## 62 6.1 3.0 4.6 1.4 ## 63 5.8 2.6 4.0 1.2 ## 64 5.6 2.7 4.2 1.3 ## 65 5.7 3.0 4.2 1.2 ## 66 5.7 2.9 4.2 1.3 ## 67 6.2 2.9 4.3 1.3 ## 68 5.1 2.5 3.0 1.1 ## 69 5.7 2.8 4.1 1.3 ## 70 6.3 3.3 6.0 2.5 ## 71 5.8 2.7 5.1 1.9 ## 72 7.1 3.0 5.9 2.1 ## 73 6.3 2.9 5.6 1.8 ## 74 6.5 3.0 5.8 2.2 ## 75 7.6 3.0 6.6 2.1 ## 76 7.3 2.9 6.3 1.8 ## 77 6.7 2.5 5.8 1.8 ## 78 7.2 3.6 6.1 2.5 ## 79 6.5 3.2 5.1 2.0 ## 80 6.4 2.7 5.3 1.9 ## 81 6.8 3.0 5.5 2.1 ## 82 5.7 2.5 5.0 2.0 ## 83 5.8 2.8 5.1 2.4 ## 84 6.4 3.2 5.3 2.3 ## 85 6.5 3.0 5.5 1.8 ## 86 7.7 3.8 6.7 2.2 ## 87 7.7 2.6 6.9 2.3 ## 88 6.0 2.2 5.0 1.5 ## 89 6.9 3.2 5.7 2.3 ## 90 5.6 2.8 4.9 2.0 ## 91 7.7 2.8 6.7 2.0 ## 92 6.3 2.7 4.9 1.8 ## 93 6.7 3.3 5.7 2.1 ## 94 7.2 3.2 6.0 1.8 ## 95 6.2 2.8 4.8 1.8 ## 96 6.1 3.0 4.9 1.8 ## 97 6.4 2.8 5.6 2.1 ## 98 7.2 3.0 5.8 1.6 ## 99 7.4 2.8 6.1 1.9 ## 100 7.9 3.8 6.4 2.0 ## 101 6.4 2.8 5.6 2.2 ## 102 6.3 2.8 5.1 1.5 ## 103 6.1 2.6 5.6 1.4 ## 104 7.7 3.0 6.1 2.3 ## 105 6.3 3.4 5.6 2.4 ## 106 6.4 3.1 5.5 1.8 ## 107 6.0 3.0 4.8 1.8 ## 108 6.9 3.1 5.4 2.1 ## 109 6.7 3.1 5.6 2.4 ## 110 6.9 3.1 5.1 2.3 ## 111 5.8 2.7 5.1 1.9 ## 112 6.8 3.2 5.9 2.3 ## 113 6.7 3.3 5.7 2.5 ## 114 6.7 3.0 5.2 2.3 ## 115 6.3 2.5 5.0 1.9 ## 116 6.5 3.0 5.2 2.0 ## 117 6.2 3.4 5.4 2.3 ## 118 5.9 3.0 5.1 1.8 Here we are filtering on every column. In one row, if any value is greater tnan 5, the row will be returned. 4.3.11 Own functions You can write your own functions to add to the end of a dplyr chain. Certain functions (e.g. mean(), sd()) expect a vector input (and not data frame). When you have a group_by() above your function (e.g. group_by(a) %&gt;% yourfunction()), subsetting within your own function with [ ] to obtain one column will give you a data frame and NOT a vector. # print the structure of the first column test_fun &lt;- function(x){ print(str(x[,1])) } iris %&gt;% group_by(Species) %&gt;% test_fun() ## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 150 obs. of 1 variable: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## NULL Using the same subsetting method on a dataframe gives you an atomic vector. This is most likely due to the behaviour of the grouped dataframe. str(iris[,1]) ## num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... To obtain an atomic vector, use [[ ]] (as a dataframe is a list): test_fun &lt;- function(x){ print(str(x[,1][[1]])) } iris %&gt;% group_by(Species) %&gt;% test_fun() ## num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## NULL 4.3.12 Join Performs the same function as merge(). Is faster? A useful reference can be found in this guide inner_join(x,y) Columns - all columns from x and y Rows - only the rows where there were matching values, in the merging columns semi_join(x,y) Columns - only columns from x Rows - only rows from X where there were matching values in y left_join(x,y) Columns - all columns from x and y Rows - only rows from x anti_join(x,y) Columns - only columns from x Rows - only rows from x where there are NOT matching values in y full_join(x,y) You will get NA values when there are things that do not match Columns - all columns Rows - all rows from both x and y. Where there is a row that is not in both x and y, it is kept and NAs fill missing values 4.4 tidyr The two most common problems when cleaning data are that one variable may be spread across multiple columns or one observation may be spread out across multiple rows. The following two functions solve this. 4.4.1 gather gather() is for when variables are spread across many columns. Goes from wide to long. Take this dataset from tidyr: table4a ## # A tibble: 3 x 3 ## country `1999` `2000` ## * &lt;chr&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 745 2666 ## 2 Brazil 37737 80488 ## 3 China 212258 213766 To convert this into ‘tidy’ data where each row is one observation we must make it longer! table4a %&gt;% gather(`1999`, `2000`, key = &quot;year&quot;, value = &quot;cases&quot;) ## # A tibble: 6 x 3 ## country year cases ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 ## 2 Brazil 1999 37737 ## 3 China 1999 212258 ## 4 Afghanistan 2000 2666 ## 5 Brazil 2000 80488 ## 6 China 2000 213766 The first arguments are the columns you wish to ‘gather’. (Note that the columns 1999 and 2000 when a column name starts with numbers, you need to surround them with backticks). The argument key tells the function what the column name of ‘type’ or gathered columns should be called. The argument value specifies what the values previously under the 1999 and 2000 columns should be named. Since there are only two columns here we can just list them, if there are more columns, you can use notation of dplyr::select to select the columns. One useful way is just to give the column numbers (e.g. gather(1:10, ...)) 4.4.2 spread spread() is for when observations are spread across many rows. Goes from long to wide. Take this dataset from tidyr: table2 ## # A tibble: 12 x 4 ## country year type count ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 Afghanistan 1999 cases 745 ## 2 Afghanistan 1999 population 19987071 ## 3 Afghanistan 2000 cases 2666 ## 4 Afghanistan 2000 population 20595360 ## 5 Brazil 1999 cases 37737 ## 6 Brazil 1999 population 172006362 ## 7 Brazil 2000 cases 80488 ## 8 Brazil 2000 population 174504898 ## 9 China 1999 cases 212258 ## 10 China 1999 population 1272915272 ## 11 China 2000 cases 213766 ## 12 China 2000 population 1280428583 On observation should have both the cases and population. Thus table2 %&gt;% spread(key = type, value = count) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 key is the column that contains names of the variables that should be spread across several columns and values are the values that should go under the new column(s). These functions are useful if you need to transform data as t() will NOT work on a tibble. Spread and gather are NOT symmetrical! For spread to work, each row must be UNIQUELY identified (see issue). iris %&gt;% gather(starts_with(&quot;Petal&quot;), key = colname, value = value) ## Sepal.Length Sepal.Width Species colname value ## 1 5.1 3.5 setosa Petal.Length 1.4 ## 2 4.9 3.0 setosa Petal.Length 1.4 ## 3 4.7 3.2 setosa Petal.Length 1.3 ## 4 4.6 3.1 setosa Petal.Length 1.5 ## 5 5.0 3.6 setosa Petal.Length 1.4 ## 6 5.4 3.9 setosa Petal.Length 1.7 ## 7 4.6 3.4 setosa Petal.Length 1.4 ## 8 5.0 3.4 setosa Petal.Length 1.5 ## 9 4.4 2.9 setosa Petal.Length 1.4 ## 10 4.9 3.1 setosa Petal.Length 1.5 ## 11 5.4 3.7 setosa Petal.Length 1.5 ## 12 4.8 3.4 setosa Petal.Length 1.6 ## 13 4.8 3.0 setosa Petal.Length 1.4 ## 14 4.3 3.0 setosa Petal.Length 1.1 ## 15 5.8 4.0 setosa Petal.Length 1.2 ## 16 5.7 4.4 setosa Petal.Length 1.5 ## 17 5.4 3.9 setosa Petal.Length 1.3 ## 18 5.1 3.5 setosa Petal.Length 1.4 ## 19 5.7 3.8 setosa Petal.Length 1.7 ## 20 5.1 3.8 setosa Petal.Length 1.5 ## 21 5.4 3.4 setosa Petal.Length 1.7 ## 22 5.1 3.7 setosa Petal.Length 1.5 ## 23 4.6 3.6 setosa Petal.Length 1.0 ## 24 5.1 3.3 setosa Petal.Length 1.7 ## 25 4.8 3.4 setosa Petal.Length 1.9 ## 26 5.0 3.0 setosa Petal.Length 1.6 ## 27 5.0 3.4 setosa Petal.Length 1.6 ## 28 5.2 3.5 setosa Petal.Length 1.5 ## 29 5.2 3.4 setosa Petal.Length 1.4 ## 30 4.7 3.2 setosa Petal.Length 1.6 ## 31 4.8 3.1 setosa Petal.Length 1.6 ## 32 5.4 3.4 setosa Petal.Length 1.5 ## 33 5.2 4.1 setosa Petal.Length 1.5 ## 34 5.5 4.2 setosa Petal.Length 1.4 ## 35 4.9 3.1 setosa Petal.Length 1.5 ## 36 5.0 3.2 setosa Petal.Length 1.2 ## 37 5.5 3.5 setosa Petal.Length 1.3 ## 38 4.9 3.6 setosa Petal.Length 1.4 ## 39 4.4 3.0 setosa Petal.Length 1.3 ## 40 5.1 3.4 setosa Petal.Length 1.5 ## 41 5.0 3.5 setosa Petal.Length 1.3 ## 42 4.5 2.3 setosa Petal.Length 1.3 ## 43 4.4 3.2 setosa Petal.Length 1.3 ## 44 5.0 3.5 setosa Petal.Length 1.6 ## 45 5.1 3.8 setosa Petal.Length 1.9 ## 46 4.8 3.0 setosa Petal.Length 1.4 ## 47 5.1 3.8 setosa Petal.Length 1.6 ## 48 4.6 3.2 setosa Petal.Length 1.4 ## 49 5.3 3.7 setosa Petal.Length 1.5 ## 50 5.0 3.3 setosa Petal.Length 1.4 ## 51 7.0 3.2 versicolor Petal.Length 4.7 ## 52 6.4 3.2 versicolor Petal.Length 4.5 ## 53 6.9 3.1 versicolor Petal.Length 4.9 ## 54 5.5 2.3 versicolor Petal.Length 4.0 ## 55 6.5 2.8 versicolor Petal.Length 4.6 ## 56 5.7 2.8 versicolor Petal.Length 4.5 ## 57 6.3 3.3 versicolor Petal.Length 4.7 ## 58 4.9 2.4 versicolor Petal.Length 3.3 ## 59 6.6 2.9 versicolor Petal.Length 4.6 ## 60 5.2 2.7 versicolor Petal.Length 3.9 ## 61 5.0 2.0 versicolor Petal.Length 3.5 ## 62 5.9 3.0 versicolor Petal.Length 4.2 ## 63 6.0 2.2 versicolor Petal.Length 4.0 ## 64 6.1 2.9 versicolor Petal.Length 4.7 ## 65 5.6 2.9 versicolor Petal.Length 3.6 ## 66 6.7 3.1 versicolor Petal.Length 4.4 ## 67 5.6 3.0 versicolor Petal.Length 4.5 ## 68 5.8 2.7 versicolor Petal.Length 4.1 ## 69 6.2 2.2 versicolor Petal.Length 4.5 ## 70 5.6 2.5 versicolor Petal.Length 3.9 ## 71 5.9 3.2 versicolor Petal.Length 4.8 ## 72 6.1 2.8 versicolor Petal.Length 4.0 ## 73 6.3 2.5 versicolor Petal.Length 4.9 ## 74 6.1 2.8 versicolor Petal.Length 4.7 ## 75 6.4 2.9 versicolor Petal.Length 4.3 ## 76 6.6 3.0 versicolor Petal.Length 4.4 ## 77 6.8 2.8 versicolor Petal.Length 4.8 ## 78 6.7 3.0 versicolor Petal.Length 5.0 ## 79 6.0 2.9 versicolor Petal.Length 4.5 ## 80 5.7 2.6 versicolor Petal.Length 3.5 ## 81 5.5 2.4 versicolor Petal.Length 3.8 ## 82 5.5 2.4 versicolor Petal.Length 3.7 ## 83 5.8 2.7 versicolor Petal.Length 3.9 ## 84 6.0 2.7 versicolor Petal.Length 5.1 ## 85 5.4 3.0 versicolor Petal.Length 4.5 ## 86 6.0 3.4 versicolor Petal.Length 4.5 ## 87 6.7 3.1 versicolor Petal.Length 4.7 ## 88 6.3 2.3 versicolor Petal.Length 4.4 ## 89 5.6 3.0 versicolor Petal.Length 4.1 ## 90 5.5 2.5 versicolor Petal.Length 4.0 ## 91 5.5 2.6 versicolor Petal.Length 4.4 ## 92 6.1 3.0 versicolor Petal.Length 4.6 ## 93 5.8 2.6 versicolor Petal.Length 4.0 ## 94 5.0 2.3 versicolor Petal.Length 3.3 ## 95 5.6 2.7 versicolor Petal.Length 4.2 ## 96 5.7 3.0 versicolor Petal.Length 4.2 ## 97 5.7 2.9 versicolor Petal.Length 4.2 ## 98 6.2 2.9 versicolor Petal.Length 4.3 ## 99 5.1 2.5 versicolor Petal.Length 3.0 ## 100 5.7 2.8 versicolor Petal.Length 4.1 ## 101 6.3 3.3 virginica Petal.Length 6.0 ## 102 5.8 2.7 virginica Petal.Length 5.1 ## 103 7.1 3.0 virginica Petal.Length 5.9 ## 104 6.3 2.9 virginica Petal.Length 5.6 ## 105 6.5 3.0 virginica Petal.Length 5.8 ## 106 7.6 3.0 virginica Petal.Length 6.6 ## 107 4.9 2.5 virginica Petal.Length 4.5 ## 108 7.3 2.9 virginica Petal.Length 6.3 ## 109 6.7 2.5 virginica Petal.Length 5.8 ## 110 7.2 3.6 virginica Petal.Length 6.1 ## 111 6.5 3.2 virginica Petal.Length 5.1 ## 112 6.4 2.7 virginica Petal.Length 5.3 ## 113 6.8 3.0 virginica Petal.Length 5.5 ## 114 5.7 2.5 virginica Petal.Length 5.0 ## 115 5.8 2.8 virginica Petal.Length 5.1 ## 116 6.4 3.2 virginica Petal.Length 5.3 ## 117 6.5 3.0 virginica Petal.Length 5.5 ## 118 7.7 3.8 virginica Petal.Length 6.7 ## 119 7.7 2.6 virginica Petal.Length 6.9 ## 120 6.0 2.2 virginica Petal.Length 5.0 ## 121 6.9 3.2 virginica Petal.Length 5.7 ## 122 5.6 2.8 virginica Petal.Length 4.9 ## 123 7.7 2.8 virginica Petal.Length 6.7 ## 124 6.3 2.7 virginica Petal.Length 4.9 ## 125 6.7 3.3 virginica Petal.Length 5.7 ## 126 7.2 3.2 virginica Petal.Length 6.0 ## 127 6.2 2.8 virginica Petal.Length 4.8 ## 128 6.1 3.0 virginica Petal.Length 4.9 ## 129 6.4 2.8 virginica Petal.Length 5.6 ## 130 7.2 3.0 virginica Petal.Length 5.8 ## 131 7.4 2.8 virginica Petal.Length 6.1 ## 132 7.9 3.8 virginica Petal.Length 6.4 ## 133 6.4 2.8 virginica Petal.Length 5.6 ## 134 6.3 2.8 virginica Petal.Length 5.1 ## 135 6.1 2.6 virginica Petal.Length 5.6 ## 136 7.7 3.0 virginica Petal.Length 6.1 ## 137 6.3 3.4 virginica Petal.Length 5.6 ## 138 6.4 3.1 virginica Petal.Length 5.5 ## 139 6.0 3.0 virginica Petal.Length 4.8 ## 140 6.9 3.1 virginica Petal.Length 5.4 ## 141 6.7 3.1 virginica Petal.Length 5.6 ## 142 6.9 3.1 virginica Petal.Length 5.1 ## 143 5.8 2.7 virginica Petal.Length 5.1 ## 144 6.8 3.2 virginica Petal.Length 5.9 ## 145 6.7 3.3 virginica Petal.Length 5.7 ## 146 6.7 3.0 virginica Petal.Length 5.2 ## 147 6.3 2.5 virginica Petal.Length 5.0 ## 148 6.5 3.0 virginica Petal.Length 5.2 ## 149 6.2 3.4 virginica Petal.Length 5.4 ## 150 5.9 3.0 virginica Petal.Length 5.1 ## 151 5.1 3.5 setosa Petal.Width 0.2 ## 152 4.9 3.0 setosa Petal.Width 0.2 ## 153 4.7 3.2 setosa Petal.Width 0.2 ## 154 4.6 3.1 setosa Petal.Width 0.2 ## 155 5.0 3.6 setosa Petal.Width 0.2 ## 156 5.4 3.9 setosa Petal.Width 0.4 ## 157 4.6 3.4 setosa Petal.Width 0.3 ## 158 5.0 3.4 setosa Petal.Width 0.2 ## 159 4.4 2.9 setosa Petal.Width 0.2 ## 160 4.9 3.1 setosa Petal.Width 0.1 ## 161 5.4 3.7 setosa Petal.Width 0.2 ## 162 4.8 3.4 setosa Petal.Width 0.2 ## 163 4.8 3.0 setosa Petal.Width 0.1 ## 164 4.3 3.0 setosa Petal.Width 0.1 ## 165 5.8 4.0 setosa Petal.Width 0.2 ## 166 5.7 4.4 setosa Petal.Width 0.4 ## 167 5.4 3.9 setosa Petal.Width 0.4 ## 168 5.1 3.5 setosa Petal.Width 0.3 ## 169 5.7 3.8 setosa Petal.Width 0.3 ## 170 5.1 3.8 setosa Petal.Width 0.3 ## 171 5.4 3.4 setosa Petal.Width 0.2 ## 172 5.1 3.7 setosa Petal.Width 0.4 ## 173 4.6 3.6 setosa Petal.Width 0.2 ## 174 5.1 3.3 setosa Petal.Width 0.5 ## 175 4.8 3.4 setosa Petal.Width 0.2 ## 176 5.0 3.0 setosa Petal.Width 0.2 ## 177 5.0 3.4 setosa Petal.Width 0.4 ## 178 5.2 3.5 setosa Petal.Width 0.2 ## 179 5.2 3.4 setosa Petal.Width 0.2 ## 180 4.7 3.2 setosa Petal.Width 0.2 ## 181 4.8 3.1 setosa Petal.Width 0.2 ## 182 5.4 3.4 setosa Petal.Width 0.4 ## 183 5.2 4.1 setosa Petal.Width 0.1 ## 184 5.5 4.2 setosa Petal.Width 0.2 ## 185 4.9 3.1 setosa Petal.Width 0.2 ## 186 5.0 3.2 setosa Petal.Width 0.2 ## 187 5.5 3.5 setosa Petal.Width 0.2 ## 188 4.9 3.6 setosa Petal.Width 0.1 ## 189 4.4 3.0 setosa Petal.Width 0.2 ## 190 5.1 3.4 setosa Petal.Width 0.2 ## 191 5.0 3.5 setosa Petal.Width 0.3 ## 192 4.5 2.3 setosa Petal.Width 0.3 ## 193 4.4 3.2 setosa Petal.Width 0.2 ## 194 5.0 3.5 setosa Petal.Width 0.6 ## 195 5.1 3.8 setosa Petal.Width 0.4 ## 196 4.8 3.0 setosa Petal.Width 0.3 ## 197 5.1 3.8 setosa Petal.Width 0.2 ## 198 4.6 3.2 setosa Petal.Width 0.2 ## 199 5.3 3.7 setosa Petal.Width 0.2 ## 200 5.0 3.3 setosa Petal.Width 0.2 ## [ reached getOption(&quot;max.print&quot;) -- omitted 100 rows ] If we try spread(): iris %&gt;% gather(starts_with(&quot;Petal&quot;), key = colname, value = value) %&gt;% spread(colname, value) ## Error: Each row of output must be identified by a unique combination of keys. ## Keys are shared for 88 rows: ## * 3, 30 ## * 13, 46 ## * 12, 25 ## * 10, 35 ## * 8, 27 ## * 41, 44 ## * 1, 18 ## * 20, 45, 47 ## * 21, 32 ## * 6, 17 ## * 81, 82 ## * 67, 89 ## * 56, 100 ## * 68, 83 ## * 102, 143 ## * 72, 74 ## * 129, 133 ## * 105, 117, 148 ## * 66, 87 ## * 125, 145 ## * 140, 142 ## * 153, 180 ## * 163, 196 ## * 162, 175 ## * 160, 185 ## * 158, 177 ## * 191, 194 ## * 151, 168 ## * 170, 195, 197 ## * 171, 182 ## * 156, 167 ## * 231, 232 ## * 217, 239 ## * 206, 250 ## * 218, 233 ## * 252, 293 ## * 222, 224 ## * 279, 283 ## * 255, 267, 298 ## * 216, 237 ## * 275, 295 ## * 290, 292 ## Do you need to create unique ID with tibble::rowid_to_column()? This is because there are rows (see error) where the values are exactly the same! tib &lt;- iris %&gt;% gather(starts_with(&quot;Petal&quot;), key = colname, value = value) tib[c(3,30),] ## Sepal.Length Sepal.Width Species colname value ## 3 4.7 3.2 setosa Petal.Length 1.3 ## 30 4.7 3.2 setosa Petal.Length 1.6 Fix by adding a unique row id: iris %&gt;% rowid_to_column() %&gt;% gather(colname, value, starts_with(&quot;Petal&quot;)) %&gt;% spread(colname, value) ## rowid Sepal.Length Sepal.Width Species Petal.Length Petal.Width ## 1 1 5.1 3.5 setosa 1.4 0.2 ## 2 2 4.9 3.0 setosa 1.4 0.2 ## 3 3 4.7 3.2 setosa 1.3 0.2 ## 4 4 4.6 3.1 setosa 1.5 0.2 ## 5 5 5.0 3.6 setosa 1.4 0.2 ## 6 6 5.4 3.9 setosa 1.7 0.4 ## 7 7 4.6 3.4 setosa 1.4 0.3 ## 8 8 5.0 3.4 setosa 1.5 0.2 ## 9 9 4.4 2.9 setosa 1.4 0.2 ## 10 10 4.9 3.1 setosa 1.5 0.1 ## 11 11 5.4 3.7 setosa 1.5 0.2 ## 12 12 4.8 3.4 setosa 1.6 0.2 ## 13 13 4.8 3.0 setosa 1.4 0.1 ## 14 14 4.3 3.0 setosa 1.1 0.1 ## 15 15 5.8 4.0 setosa 1.2 0.2 ## 16 16 5.7 4.4 setosa 1.5 0.4 ## 17 17 5.4 3.9 setosa 1.3 0.4 ## 18 18 5.1 3.5 setosa 1.4 0.3 ## 19 19 5.7 3.8 setosa 1.7 0.3 ## 20 20 5.1 3.8 setosa 1.5 0.3 ## 21 21 5.4 3.4 setosa 1.7 0.2 ## 22 22 5.1 3.7 setosa 1.5 0.4 ## 23 23 4.6 3.6 setosa 1.0 0.2 ## 24 24 5.1 3.3 setosa 1.7 0.5 ## 25 25 4.8 3.4 setosa 1.9 0.2 ## 26 26 5.0 3.0 setosa 1.6 0.2 ## 27 27 5.0 3.4 setosa 1.6 0.4 ## 28 28 5.2 3.5 setosa 1.5 0.2 ## 29 29 5.2 3.4 setosa 1.4 0.2 ## 30 30 4.7 3.2 setosa 1.6 0.2 ## 31 31 4.8 3.1 setosa 1.6 0.2 ## 32 32 5.4 3.4 setosa 1.5 0.4 ## 33 33 5.2 4.1 setosa 1.5 0.1 ## 34 34 5.5 4.2 setosa 1.4 0.2 ## 35 35 4.9 3.1 setosa 1.5 0.2 ## 36 36 5.0 3.2 setosa 1.2 0.2 ## 37 37 5.5 3.5 setosa 1.3 0.2 ## 38 38 4.9 3.6 setosa 1.4 0.1 ## 39 39 4.4 3.0 setosa 1.3 0.2 ## 40 40 5.1 3.4 setosa 1.5 0.2 ## 41 41 5.0 3.5 setosa 1.3 0.3 ## 42 42 4.5 2.3 setosa 1.3 0.3 ## 43 43 4.4 3.2 setosa 1.3 0.2 ## 44 44 5.0 3.5 setosa 1.6 0.6 ## 45 45 5.1 3.8 setosa 1.9 0.4 ## 46 46 4.8 3.0 setosa 1.4 0.3 ## 47 47 5.1 3.8 setosa 1.6 0.2 ## 48 48 4.6 3.2 setosa 1.4 0.2 ## 49 49 5.3 3.7 setosa 1.5 0.2 ## 50 50 5.0 3.3 setosa 1.4 0.2 ## 51 51 7.0 3.2 versicolor 4.7 1.4 ## 52 52 6.4 3.2 versicolor 4.5 1.5 ## 53 53 6.9 3.1 versicolor 4.9 1.5 ## 54 54 5.5 2.3 versicolor 4.0 1.3 ## 55 55 6.5 2.8 versicolor 4.6 1.5 ## 56 56 5.7 2.8 versicolor 4.5 1.3 ## 57 57 6.3 3.3 versicolor 4.7 1.6 ## 58 58 4.9 2.4 versicolor 3.3 1.0 ## 59 59 6.6 2.9 versicolor 4.6 1.3 ## 60 60 5.2 2.7 versicolor 3.9 1.4 ## 61 61 5.0 2.0 versicolor 3.5 1.0 ## 62 62 5.9 3.0 versicolor 4.2 1.5 ## 63 63 6.0 2.2 versicolor 4.0 1.0 ## 64 64 6.1 2.9 versicolor 4.7 1.4 ## 65 65 5.6 2.9 versicolor 3.6 1.3 ## 66 66 6.7 3.1 versicolor 4.4 1.4 ## 67 67 5.6 3.0 versicolor 4.5 1.5 ## 68 68 5.8 2.7 versicolor 4.1 1.0 ## 69 69 6.2 2.2 versicolor 4.5 1.5 ## 70 70 5.6 2.5 versicolor 3.9 1.1 ## 71 71 5.9 3.2 versicolor 4.8 1.8 ## 72 72 6.1 2.8 versicolor 4.0 1.3 ## 73 73 6.3 2.5 versicolor 4.9 1.5 ## 74 74 6.1 2.8 versicolor 4.7 1.2 ## 75 75 6.4 2.9 versicolor 4.3 1.3 ## 76 76 6.6 3.0 versicolor 4.4 1.4 ## 77 77 6.8 2.8 versicolor 4.8 1.4 ## 78 78 6.7 3.0 versicolor 5.0 1.7 ## 79 79 6.0 2.9 versicolor 4.5 1.5 ## 80 80 5.7 2.6 versicolor 3.5 1.0 ## 81 81 5.5 2.4 versicolor 3.8 1.1 ## 82 82 5.5 2.4 versicolor 3.7 1.0 ## 83 83 5.8 2.7 versicolor 3.9 1.2 ## 84 84 6.0 2.7 versicolor 5.1 1.6 ## 85 85 5.4 3.0 versicolor 4.5 1.5 ## 86 86 6.0 3.4 versicolor 4.5 1.6 ## 87 87 6.7 3.1 versicolor 4.7 1.5 ## 88 88 6.3 2.3 versicolor 4.4 1.3 ## 89 89 5.6 3.0 versicolor 4.1 1.3 ## 90 90 5.5 2.5 versicolor 4.0 1.3 ## 91 91 5.5 2.6 versicolor 4.4 1.2 ## 92 92 6.1 3.0 versicolor 4.6 1.4 ## 93 93 5.8 2.6 versicolor 4.0 1.2 ## 94 94 5.0 2.3 versicolor 3.3 1.0 ## 95 95 5.6 2.7 versicolor 4.2 1.3 ## 96 96 5.7 3.0 versicolor 4.2 1.2 ## 97 97 5.7 2.9 versicolor 4.2 1.3 ## 98 98 6.2 2.9 versicolor 4.3 1.3 ## 99 99 5.1 2.5 versicolor 3.0 1.1 ## 100 100 5.7 2.8 versicolor 4.1 1.3 ## 101 101 6.3 3.3 virginica 6.0 2.5 ## 102 102 5.8 2.7 virginica 5.1 1.9 ## 103 103 7.1 3.0 virginica 5.9 2.1 ## 104 104 6.3 2.9 virginica 5.6 1.8 ## 105 105 6.5 3.0 virginica 5.8 2.2 ## 106 106 7.6 3.0 virginica 6.6 2.1 ## 107 107 4.9 2.5 virginica 4.5 1.7 ## 108 108 7.3 2.9 virginica 6.3 1.8 ## 109 109 6.7 2.5 virginica 5.8 1.8 ## 110 110 7.2 3.6 virginica 6.1 2.5 ## 111 111 6.5 3.2 virginica 5.1 2.0 ## 112 112 6.4 2.7 virginica 5.3 1.9 ## 113 113 6.8 3.0 virginica 5.5 2.1 ## 114 114 5.7 2.5 virginica 5.0 2.0 ## 115 115 5.8 2.8 virginica 5.1 2.4 ## 116 116 6.4 3.2 virginica 5.3 2.3 ## 117 117 6.5 3.0 virginica 5.5 1.8 ## 118 118 7.7 3.8 virginica 6.7 2.2 ## 119 119 7.7 2.6 virginica 6.9 2.3 ## 120 120 6.0 2.2 virginica 5.0 1.5 ## 121 121 6.9 3.2 virginica 5.7 2.3 ## 122 122 5.6 2.8 virginica 4.9 2.0 ## 123 123 7.7 2.8 virginica 6.7 2.0 ## 124 124 6.3 2.7 virginica 4.9 1.8 ## 125 125 6.7 3.3 virginica 5.7 2.1 ## 126 126 7.2 3.2 virginica 6.0 1.8 ## 127 127 6.2 2.8 virginica 4.8 1.8 ## 128 128 6.1 3.0 virginica 4.9 1.8 ## 129 129 6.4 2.8 virginica 5.6 2.1 ## 130 130 7.2 3.0 virginica 5.8 1.6 ## 131 131 7.4 2.8 virginica 6.1 1.9 ## 132 132 7.9 3.8 virginica 6.4 2.0 ## 133 133 6.4 2.8 virginica 5.6 2.2 ## 134 134 6.3 2.8 virginica 5.1 1.5 ## 135 135 6.1 2.6 virginica 5.6 1.4 ## 136 136 7.7 3.0 virginica 6.1 2.3 ## 137 137 6.3 3.4 virginica 5.6 2.4 ## 138 138 6.4 3.1 virginica 5.5 1.8 ## 139 139 6.0 3.0 virginica 4.8 1.8 ## 140 140 6.9 3.1 virginica 5.4 2.1 ## 141 141 6.7 3.1 virginica 5.6 2.4 ## 142 142 6.9 3.1 virginica 5.1 2.3 ## 143 143 5.8 2.7 virginica 5.1 1.9 ## 144 144 6.8 3.2 virginica 5.9 2.3 ## 145 145 6.7 3.3 virginica 5.7 2.5 ## 146 146 6.7 3.0 virginica 5.2 2.3 ## 147 147 6.3 2.5 virginica 5.0 1.9 ## 148 148 6.5 3.0 virginica 5.2 2.0 ## 149 149 6.2 3.4 virginica 5.4 2.3 ## 150 150 5.9 3.0 virginica 5.1 1.8 4.4.3 separate Separates one column into multiple columns. By default it will split on non-alphanumeric characters (i.e. any character that is not a letter or number, like ‘/’) Take this dataset from tidyr: table3 ## # A tibble: 6 x 3 ## country year rate ## * &lt;chr&gt; &lt;int&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745/19987071 ## 2 Afghanistan 2000 2666/20595360 ## 3 Brazil 1999 37737/172006362 ## 4 Brazil 2000 80488/174504898 ## 5 China 1999 212258/1272915272 ## 6 China 2000 213766/1280428583 table3 %&gt;% separate(rate, into = c(&quot;cases&quot;, &quot;population&quot;)) ## # A tibble: 6 x 4 ## country year cases population ## &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Afghanistan 1999 745 19987071 ## 2 Afghanistan 2000 2666 20595360 ## 3 Brazil 1999 37737 172006362 ## 4 Brazil 2000 80488 174504898 ## 5 China 1999 212258 1272915272 ## 6 China 2000 213766 1280428583 into - lets you specify the new column names. sep - allows you specify on what character to separate. Formally it is a regex. convert - by default the function will leave the datatype of the new columns as what it was originally (in the single column), convert = TRUE converts the new columns. "],
["string-manipulation.html", "Chapter 5 String manipulation 5.1 Grep family 5.2 Regular expressions", " Chapter 5 String manipulation Useful references: Handling and processing strings in R Paul Murrell’s notes Regular expressions in R - several examples were taken from here. Regular expression info 5.1 Grep family grep() - gives you each element in the vector that matches your pattern. value=FALSE returns indices of matches, value=TRUE returns the the matches. invert argument allows you to return everything but the matches. grepl() - returns a logical vector telling you which elements in your vector matches your pattern. strings &lt;- c(&quot;a&quot;, &quot;ab&quot;, &quot;acb&quot;, &quot;accb&quot;, &quot;acccb&quot;, &quot;accccb&quot;) grep(&quot;ac&quot;, strings, value = TRUE) ## [1] &quot;acb&quot; &quot;accb&quot; &quot;acccb&quot; &quot;accccb&quot; grepl(&quot;ac&quot;, strings) ## [1] FALSE FALSE TRUE TRUE TRUE TRUE 5.1.1 Locating pattern within string Each element is searched separately. Information sufficient to extract the pattern is returned: An integer vector indicating the character position in each element, where either the first, or all regex match was found. Each element also has a match.length attribute, which gives the length of the match. If pattern is not found, -1 is returned. regexpr() - returns vector, giving the first match found for each element in input vector. gregexpr() - returns list, giving all matches found for each element in input vector. We can look for the pattern ‘cc’ in strings: str(regexpr(&#39;cc&#39;, strings)) ## int [1:6] -1 -1 -1 2 2 2 ## - attr(*, &quot;match.length&quot;)= int [1:6] -1 -1 -1 2 2 2 ## - attr(*, &quot;index.type&quot;)= chr &quot;chars&quot; ## - attr(*, &quot;useBytes&quot;)= logi TRUE The output is a vector of the same length as strings. Each element in the vector is the first index within each string in strings that matched the pattern. Each elemetn also has a match.length attribute which gives the length of the match. As the pattern was two characters in length, all the match.lengths are ‘2’. str(gregexpr(&#39;cc&#39;, strings)) ## List of 6 ## $ : int -1 ## ..- attr(*, &quot;match.length&quot;)= int -1 ## ..- attr(*, &quot;index.type&quot;)= chr &quot;chars&quot; ## ..- attr(*, &quot;useBytes&quot;)= logi TRUE ## $ : int -1 ## ..- attr(*, &quot;match.length&quot;)= int -1 ## ..- attr(*, &quot;index.type&quot;)= chr &quot;chars&quot; ## ..- attr(*, &quot;useBytes&quot;)= logi TRUE ## $ : int -1 ## ..- attr(*, &quot;match.length&quot;)= int -1 ## ..- attr(*, &quot;index.type&quot;)= chr &quot;chars&quot; ## ..- attr(*, &quot;useBytes&quot;)= logi TRUE ## $ : int 2 ## ..- attr(*, &quot;match.length&quot;)= int 2 ## ..- attr(*, &quot;index.type&quot;)= chr &quot;chars&quot; ## ..- attr(*, &quot;useBytes&quot;)= logi TRUE ## $ : int 2 ## ..- attr(*, &quot;match.length&quot;)= int 2 ## ..- attr(*, &quot;index.type&quot;)= chr &quot;chars&quot; ## ..- attr(*, &quot;useBytes&quot;)= logi TRUE ## $ : int [1:2] 2 4 ## ..- attr(*, &quot;match.length&quot;)= int [1:2] 2 2 ## ..- attr(*, &quot;index.type&quot;)= chr &quot;chars&quot; ## ..- attr(*, &quot;useBytes&quot;)= logi TRUE gregexpr() gives you ALL the matches. The output is thus a list as the number of matches can vary for each element in the text (strings here). Again ‘-1’ indicates taht there were no matches. The one difference is that in the last element ‘accccb’, the pattern ‘cc’ matches twice - once at index 2 and once at index 4. You can also change the pattern from an ‘exact match’ to a regular expression. Here we are looking for the pattern ‘cc’ ‘at least once’ - instead of the exact pattern ‘cc’. str(regexpr(&#39;cc+&#39;, strings)) ## int [1:6] -1 -1 -1 2 2 2 ## - attr(*, &quot;match.length&quot;)= int [1:6] -1 -1 -1 2 3 4 ## - attr(*, &quot;index.type&quot;)= chr &quot;chars&quot; ## - attr(*, &quot;useBytes&quot;)= logi TRUE Adding the + to the pattern says that we are looking for ‘cc’ to occur at least once. The result of this change is that match.length now gives the full length of c’s in each element (as long as it is longer than twoº. To get the actual substrings matched by the pattern, use regmatches() after the above functions. If you pass the output from regexpr() to regmatches(), a character vector is with all the strings that matched is returned. This vector is shorter than the input vector if no match was found in some of the elements. regmatches() takes two arguments, the vector of strings the pattern was searched for in and the output from a regex. regmatches(strings, regexpr(&#39;cc&#39;, strings)) ## [1] &quot;cc&quot; &quot;cc&quot; &quot;cc&quot; If you pass the output from gregexpr() to regmatches() a list the same length as the input vector will be output. Each element is a character vector with all the matches of the corresponding element in the input vector, or ‘character(0)’ if an element had no matches. regmatches(strings, gregexpr(&#39;cc&#39;, strings)) ## [[1]] ## character(0) ## ## [[2]] ## character(0) ## ## [[3]] ## character(0) ## ## [[4]] ## [1] &quot;cc&quot; ## ## [[5]] ## [1] &quot;cc&quot; ## ## [[6]] ## [1] &quot;cc&quot; &quot;cc&quot; 5.1.2 Replacments A very powerful way of making replacements in a string is to assign a new list to the regmatches() function when you call it on the output of gregexpr(). x &lt;- c(&quot;abc&quot;, &quot;def&quot;, &quot;cba a&quot;, &quot;aa&quot;) m &lt;- gregexpr(&quot;a+&quot;, x) regmatches(x, m) ## [[1]] ## [1] &quot;a&quot; ## ## [[2]] ## character(0) ## ## [[3]] ## [1] &quot;a&quot; &quot;a&quot; ## ## [[4]] ## [1] &quot;aa&quot; First, notice how in the third element of x, ‘a+’ matched twice, which in the fourth element, it matched only once. This is because we are looking for at least one ‘a’ but there was a space between the two a’s in the third element. list(c(&quot;one&quot;), character(0), c(&quot;two&quot;, &quot;three&quot;), c(&quot;four&quot;)) ## [[1]] ## [1] &quot;one&quot; ## ## [[2]] ## character(0) ## ## [[3]] ## [1] &quot;two&quot; &quot;three&quot; ## ## [[4]] ## [1] &quot;four&quot; regmatches(x, m) &lt;- list(c(&quot;one&quot;), character(0), c(&quot;two&quot;, &quot;three&quot;), c(&quot;four&quot;)) x ## [1] &quot;onebc&quot; &quot;def&quot; &quot;cbtwo three&quot; &quot;four&quot; All the matches were replaced by the words in the list. The list you assign should have as many elements as the original input vector. Each element should be a character vector of the same length as the number of matches in that element. The original input vector is then modified to have all the regex matches replaced with the text from the new vector. This can also be done using these two functions: sub() - replace first occurrence. gsub() - replace all occurrences. You can match and replace an exact phrase: string &lt;- c(&quot;122 trfr (2.3%) fdfd&quot;, &quot;122 trfr (2.3%) fdfd&quot;) sub(&#39;122&#39;, &quot;**&quot; , string) ## [1] &quot;** trfr (2.3%) fdfd&quot; &quot;** trfr (2.3%) fdfd&quot; Or you can use a a regular expression (\\\\d means any number): sub(&#39;\\\\d&#39;, &quot;**&quot; , string) ## [1] &quot;**22 trfr (2.3%) fdfd&quot; &quot;**22 trfr (2.3%) fdfd&quot; 5.1.3 Backreferences You can use backreferences to reinsert text matched by capturing a group. Bascially you can retrieve the bits that matched various parts of your regular expression to alter them or use them for building up a new string. string &lt;- &quot;The cat sat on the mat.&quot; gsub(&quot;(.)at&quot;, &quot;\\\\1ot&quot;, string) ## [1] &quot;The cot sot on the mot.&quot; \\\\1 is referring to the first match of the pattern “(.)at” (which is any three-letter word ending with ‘at’). Thus three-letter word ending in ‘at’ is replaced by a three-letter word with the original starting letter but ending in ‘ot’. You can only refer to backreference \\1 to \\9 (i.e. the first to ninth match). If you wish to return entire match, place entire regex in a capturing group and use \\1. If you are using capturing group, your regex needs to consider the entire string, and use () to specify which ones you are interested in. The (...) allows for grouping in regular expressions so you can retrieve the bits that matched various parts of your regular expression so you can alter them or use them for building up a new string. Each group can than be referred to using \\\\N, with N being the number of the grouping to be used. An important note is the the regular expression pattern used with in sub() or gsub() and backreferences MUST consider the whole string and use ( ) to specify the parts you are interested in. With all other functions and examples, you can imply imput the specific string pattern you are looking for. See this page in ‘Regular expressions in R’ for more. 5.2 Regular expressions 5.2.1 Quantifiers How many times the letter/pattern occurs. * - matches at least 0 times. + - matches at least 1 times. ? - matches at most 1 times. {n} - matches exactly n times. {n,} - matches at least n times. {n,m} - matches between n and m times. grep(&quot;ac*b&quot;, strings, value = TRUE) ## [1] &quot;ab&quot; &quot;acb&quot; &quot;accb&quot; &quot;acccb&quot; &quot;accccb&quot; This looks for pattern with ‘a’, 0 to infinite c(’s) and then b. 5.2.2 Position ^ - matches the start of the string. $ - matches the end of the string. \\b - matches the empty string at either edge of a word. Don’t confuse it with ^ and $ which marks the edge of a string. \\B - matches the empty string provided it is not at an edge of a word. 5.2.3 Operators * - matches any single character, as shown in the first example. [...] - a character list, matches any one of the characters inside the square brackets. We can also use - inside the brackets to specify a range of characters. [^...] - an inverted character list, similar to [...], but matches any characters except those inside the square brackets. \\ - suppress the special meaning of metacharacters in the regular expression. Metacharacters in R are: $ * + . ? [ ] ^ { } | ( ) \\. Further, since \\ itself needs to be escaped in R, we need to escape these metacharacters with double backslash (E.g. \\\\$). This is unique to R. (See this question on SO for more. | - an ‘or’ operator. Matches patterns on either side of the |. (...) - grouping in regular expressions. Each group can than be referred to using \\\\N - see backreferennces above. with N being the No. of (…) used. 5.2.4 Character classes [:digit:] or \\\\d - digits, 0 1 2 3 4 5 6 7 8 9, equivalent to [0-9]. \\D - non-digits, equivalent to [^0-9]. [:lower:] - lower-case letters, equivalent to [a-z]. [:upper:] - upper-case letters, equivalent to [A-Z]. [:alpha:] - alphabetic characters, equivalent to [[:lower:][:upper:]] or [A-z]. [:alnum:] - alphanumeric characters, equivalent to [[:alpha:][:digit:]] or [A-z0-9]. \\w - word characters (any character used in words), equivalent to [[:alnum:]_] or [A-z0-9_]. \\W - not word, equivalent to [^A-z0-9_]. [:xdigit:] - hexadecimal digits (base 16), 0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f, equivalent to [0-9A-Fa-f]. [:blank:] - blank characters, i.e. space and tab. [:space:] - space characters: tab, newline, vertical tab, form feed, carriage return, space. \\s - space, ` `. \\S - not space. [:punct:] - punctuation characters, ! &quot; # $ % &amp; ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [ ] ^ _ ` { | } ~. [:graph:] - graphical (human readable) characters: equivalent to [[:alnum:][:punct:]]. [:print:] - printable characters, equivalent to [[:alnum:][:punct:]\\\\s]. [:cntrl:] - control characters, like or , [\\x00-\\x1F\\x7F]. Notes: * [:...:] has to be used inside square brackets, e.g. [[:digit:]]. * \\ itself is a special character that needs escape, e.g. \\\\d. Do not confuse these regular expressions with R escape sequences such as . 5.2.5 Examples Too look for a string that is ALL (or only) digits/letters, use ^ and $: &quot;^[[:digit:]]+$&quot; "],
["control-flow.html", "Chapter 6 Control flow 6.1 For loops", " Chapter 6 Control flow 6.1 For loops A for loop can be inefficient in R if you are growing a data structure (e.g. dataframe) because R will recreate the object in memory at each iteration. However, if you create a vector of the correct size (or of a size that you know will be more than enough) outside of the for loop, then fill this vector in your loop, it is more efficient. In this case R will create a structure with enough slots prior to the loop, instead of asking for more space at each iteration. A good reference on this isse is this blog Objects created in a for loop are global. This is as opposed to objects created within a function, which are local. 6.1.1 Creating empty data structures Atomic vector can be created with any of these functions. The only argument they take is the length of the vector. str(logical(10)) ## logi [1:10] FALSE FALSE FALSE FALSE FALSE FALSE ... Empty logical vectors are filled with FALSE by default. str(numeric(10)) ## num [1:10] 0 0 0 0 0 0 0 0 0 0 str(double(10)) ## num [1:10] 0 0 0 0 0 0 0 0 0 0 str(integer(10)) ## int [1:10] 0 0 0 0 0 0 0 0 0 0 Empty number vectors are filled with 0’s by default. str(character(10)) ## chr [1:10] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Empty mumeric vectors are filled with empty strings by default. You can also create a vector using vector(): str(vector(mode = &quot;character&quot;, length = 10)) ## chr [1:10] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; A list can be created using this function: str(vector(mode = &quot;list&quot;, length = 10)) ## List of 10 ## $ : NULL ## $ : NULL ## $ : NULL ## $ : NULL ## $ : NULL ## $ : NULL ## $ : NULL ## $ : NULL ## $ : NULL ## $ : NULL An empty list is filled with NULLs by default. An empty matrix can be created thus: str( matrix(nrow=2, ncol = 2) ) ## logi [1:2, 1:2] NA NA NA NA An empty matrix is filled with NAs by default. A dataframe can be created in two ways: str( data.frame(col1 = numeric(10), col2 = character(10), stringsAsFactors = FALSE) ) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ col1: num 0 0 0 0 0 0 0 0 0 0 ## $ col2: chr &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... It is important to add stringsAsFactors = FALSE, otherwise character vectors will be automatically converted into factors. str( data.frame(matrix(nrow=2, ncol = 2)) ) ## &#39;data.frame&#39;: 2 obs. of 2 variables: ## $ X1: logi NA NA ## $ X2: logi NA NA Growing a dataframe efficiently in R is difficult. The best option may be to create vectors in the loop and then join the vectors. x &lt;- numeric(n) y &lt;- character(n) for (i in 1:n) { x[i] &lt;- i y[i] &lt;- i } data.frame(x, y, stringsAsFactors=FALSE) See this question on SO for more. (There is also a data.table method - see this SO question and section 888 for more.) "],
["functions.html", "Chapter 7 Functions 7.1 Source code 7.2 Writing functions 7.3 Messages 7.4 Functions with dplyr 7.5 ggplot", " Chapter 7 Functions Useful definition: parameter is what is given in the function declaration/definition. argument is what is passed when called the function. 7.1 Source code You can view the source code of functions in R. For ‘Generic’ S3 objects (in RStudio): Type in the function name with no ‘()’. Press F2 when your cursor is over the function methods() will list all the methods for a particular generic function or class. For S4 objects just typing in the function name does not give you the source code. It will give some other useful information - e.g. if it says ‘standardGeneric’ means tells you that it is a S4 function. showMethods() - tells you the available methods for that function (e.g. if a function performs a slightly different thing depending on the class of object given to it). getMethod() - can then be used to see the source code for one of the available methods in showMethods. (see this SO question for more). 7.2 Writing functions Standard syntax: function_name &lt;- function(param1, param2) { result &lt;- param1 - param2 return(result) } 7.2.1 Evaluation For column names the $ operator will not work if passed in as argument. foo &lt;- function(df,col_name, col1,col2){ df$col_name &lt;- df$col1 + df$col2 df } Above function does not work - as the function will look for a column called ‘col1’ instead of evaluating expression col1 (i.e. the column name assigned to the argument col1). The easiest solution is to use [[: new_column1 &lt;- function(df,col_name,col1,col2){ #Create new column col_name as sum of col1 and col2 df[[col_name]] &lt;- df[[col1]] + df[[col2]] df } Note when using [[ , you need to quote the column names, thus the argument should be given as a string. See this question on SO for more. 7.2.2 Checking inputs assert_that() from the asserthat package lets you check inputs and provdie error messages. assert_that(is.logical(reps), length(reps) == 1, msg = &quot;error message&quot;) The function will stop and the error message displayed if EITHER of the two conditions are not met. assert_that will automatically format your error messages so that even if you put a newline in your code, it will print well for the user. If you are not using assert_that(), you can use strwrap() to wrap long error messages, so they do not overflow 80 characters in your code but when printed it will fit screen of the user. See this question on SO for more. 7.3 Messages There are two types of output messages: Standard output - `print() and cat() sends to stdout Standard error - these are able to be suppressed using supressWarnings(). Useful if the user is using knitr/sweave. When using a R script on the command line - you can redirect standard out and standard error (recall 1 is standard out, 2 is standard error). Standard out print() Need to use with paste to concatenate terms. Prints [x] at the start, where x indicates the element of the term. cat() Allows concatenation and has the sep argument. Need to either for new lines with ‘’ or fill = TRUE (uses default print width). Standard error message() Output is usually red. Allows concatenation but no sep argument. warning() ‘Warning message’ line preappended to it. Do not use lightly - sometimes treated as errors during testing. stop() Stops the task at hand. ‘Error:’ printed at the start of the line. 7.3.1 Optional arguments Use missing(). Below, y is an optional argument. fooBar &lt;- function(x,y){ if(missing(y)) { x } else { x + y } } 7.4 Functions with dplyr References: dplyr documentation, SO 7.4.1 Non standard evaluation Non standard evalation is a catch-all term that means dplyr functions do not follow the usual R rules of evaluation. There are two main benefits of this: Saving on typing. You do not have to type df name again: filter(df, x == 1, y == 2, z == 3) instead of df[df$x == 1 &amp; df$y ==2 &amp; df$z == 3, ]. dplyr can choose to compute results in a different way to base R. This is important for database backends because dplyr itself doesn’t do any work, but instead generates the SQL that tells the database what to do. The drawbacks: dplyr arguments are not ‘referentially transparent’. You cannot replace a value with a seemingly equivalence object that you’ve defined elsewhere. # define df df &lt;- tibble(x = 1:3, y = 3:1) This code: filter(df, x == 1) ## # A tibble: 1 x 2 ## x y ## &lt;int&gt; &lt;int&gt; ## 1 1 3 is NOT the same as this code: my_var &lt;- x filter(df, my_var == 1) ## Error: Result must have length 3, not 4 Nor this code: my_var &lt;- &quot;x&quot; filter(df, my_var == 1) ## # A tibble: 0 x 2 ## # … with 2 variables: x &lt;int&gt;, y &lt;int&gt; This makes creating functions with arguments that need to be used with dplyr functions. The code is ambiguous. Depending on what variables are defined where, filter(df, x == y) could be equivalent to any of: df[df$x == df$y, ] df[df$x == y, ] df[x == df$y, ] df[x == y, ] Analogous evaluation problem: greet &lt;- function(name) { &quot;How do you do, name?&quot; } greet(&quot;Hadley&quot;) ## [1] &quot;How do you do, name?&quot; The quotes in: &quot;How do you do, name?&quot; mean that it doesn’t interpret what you’ve typed. It just stores it in a string. 7.4.2 Writing dplyr functions dplyr does not do anything special with the 1st argument, the data object. This works fine: mutate_y &lt;- function(df) { mutate(df, y = a + x) } Though, it can silently fail if one of the variables is not present in the data frame but present in the global environment. For example, if you wanted function that added two columns - ‘y = column a + column x’. However, there is no column a but in the global environment there is a variable a. a &lt;- 3 mutate_y &lt;- function(df) { mutate(df, y = a + x) } The above code will add the variable a, to the column x. To prevent this, you can use this more explicit code: mutate_y &lt;- function(df) { mutate(df, y = .data$a + .data$x) } .data specifies that you want to use the columns of the dataframe. If you want one of the arguments in your function to be a variable name or an expression (e.g. x+y) - you need to handle this specially. For example, if you want to write a function that does this: my_summarise &lt;- function(df, group_var) { df %&gt;% group_by(group_var) %&gt;% summarise(a = mean(Petal.Length)) } my_summarise(iris, Species) ## Error: Column `group_var` is unknown An error is given. This is because dplyr ‘quotes’ the input to group_by(). It does not evaluate what you give it (here group_var). To fix this we need to do 2 things: We need to quote the input ourselves. We use quo() which returns a quosure, which is a special type of formula. This has 2 uses: If we just give an unquoted argument, R will use it as a variable. It will then tell you it can’t find this variable. quo() function quotes its input. We cannot just use ‘’ as it would give us a string. quo() captures the expression and its environment. We then need to tell the dplyr function to not quote its input as we have already done it. We can do this with !!. my_summarise &lt;- function(df, group_var) { df %&gt;% group_by(!! group_var) %&gt;% summarise(a = mean(Petal.Length)) } my_summarise(iris, quo(Species)) ## # A tibble: 3 x 2 ## Species a ## &lt;fct&gt; &lt;dbl&gt; ## 1 setosa 1.46 ## 2 versicolor 4.26 ## 3 virginica 5.55 But what if we did not want to give quo(group_var)? We can try this: my_summarise &lt;- function(df, group_var) { quo_group_var &lt;- quo(group_var) print(quo_group_var) df %&gt;% group_by(!! quo_group_var) %&gt;% summarise(a = mean(Petal.Length)) } my_summarise(iris, Species) ## &lt;quosure&gt; ## expr: ^group_var ## env: 0x102cd1b30 ## Error: Column `group_var` is unknown This error occurs because quo(group_var) actually quotes ‘group_var’. What we want is for it to substitute the value that the user supplied. Instead we can use enquo(). This function looks at the argument, see what the actual input was and quotes that (instead of the parameter name). my_summarise &lt;- function(df, group_var) { group_var &lt;- enquo(group_var) print(group_var) df %&gt;% group_by(!! group_var) %&gt;% summarise(a = mean(Petal.Length)) } Other options are: col1 &lt;- &quot;Sepal.Length&quot; iris %&gt;% filter(UQ(as.name(col1)) &gt; 5.5) col1 &lt;- &quot;Sepal.Length&quot; iris %&gt;% filter(!!(as.name(col1)) &gt; 5.5) The !! function works (in a dplyr pipe) even if you do not have rlang (the package the function comes from) loaded. 7.5 ggplot ggplot also uses non-standard evaluation - you can refer to columns in your data without specifying the dataframe first. Again, this means that you have to do something special if you want to use ggplot in a function and refer to columns provided as arguments to your function. Use aes_string instead of aes(): aes() does complicated munging to get the names of the variables. aes_string() works directly with strings. aes_string(x = &quot;mpg&quot;, y = &quot;wt&quot;) is equal to aes(x = mpg, y = wt). f &lt;- function(column) { ... ggplot(df, aes_string(x = &quot;col1&quot;, y = &quot;col2&quot;, colour = column, group = column) ) } Column name arguments passed to your function must be quoted. You can also use get(): ggplot(d, aes(x = name, y = rate, colour = get(column), group = get(column))) See this question on SO for more. "],
["data-table.html", "Chapter 8 data.table 8.1 fread 8.2 Subsetting 8.3 Functions 8.4 Grouping 8.5 Keys 8.6 set 8.7 Reshaping 8.8 Merge", " Chapter 8 data.table Useful references: Vignettes and documentation cheatsheet Stevie’s blog Franks tutorial on joins The flights dataset will be used for examples. library(nycflights13) library(data.table) ## Warning: package &#39;data.table&#39; was built under R version 3.5.2 ## data.table 1.12.0 Latest news: r-datatable.com ## ## Attaching package: &#39;data.table&#39; ## The following objects are masked from &#39;package:dplyr&#39;: ## ## between, first, last ## The following object is masked from &#39;package:purrr&#39;: ## ## transpose flights_dt &lt;- as.data.table(flights[complete.cases(flights),]) str(flights_dt) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 327346 obs. of 19 variables: ## $ year : int 2013 2013 2013 2013 2013 2013 2013 2013 2013 2013 ... ## $ month : int 1 1 1 1 1 1 1 1 1 1 ... ## $ day : int 1 1 1 1 1 1 1 1 1 1 ... ## $ dep_time : int 517 533 542 544 554 554 555 557 557 558 ... ## $ sched_dep_time: int 515 529 540 545 600 558 600 600 600 600 ... ## $ dep_delay : num 2 4 2 -1 -6 -4 -5 -3 -3 -2 ... ## $ arr_time : int 830 850 923 1004 812 740 913 709 838 753 ... ## $ sched_arr_time: int 819 830 850 1022 837 728 854 723 846 745 ... ## $ arr_delay : num 11 20 33 -18 -25 12 19 -14 -8 8 ... ## $ carrier : chr &quot;UA&quot; &quot;UA&quot; &quot;AA&quot; &quot;B6&quot; ... ## $ flight : int 1545 1714 1141 725 461 1696 507 5708 79 301 ... ## $ tailnum : chr &quot;N14228&quot; &quot;N24211&quot; &quot;N619AA&quot; &quot;N804JB&quot; ... ## $ origin : chr &quot;EWR&quot; &quot;LGA&quot; &quot;JFK&quot; &quot;JFK&quot; ... ## $ dest : chr &quot;IAH&quot; &quot;IAH&quot; &quot;MIA&quot; &quot;BQN&quot; ... ## $ air_time : num 227 227 160 183 116 150 158 53 140 138 ... ## $ distance : num 1400 1416 1089 1576 762 ... ## $ hour : num 5 5 5 5 6 5 6 6 6 6 ... ## $ minute : num 15 29 40 45 0 58 0 0 0 0 ... ## $ time_hour : POSIXct, format: &quot;2013-01-01 05:00:00&quot; &quot;2013-01-01 05:00:00&quot; ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; 8.1 fread Memory mapping - instead of reading in data, map the content of the file to a pointer. Very fast as the data on disk mapped directly to memory without coping. This is more likely to cause bus error though. This is what python does. The advantage is that it makes reading in files a lots faster but there may be differences in performance in subsequent wrangling. The memory mapping works row wise (in python and C so probably in fread() too). If you are working with the whole dataframe, finding average of column is probably faster if the whole data has been read into memory. However for very large datasets, it is impossible to read the whole df into memory. If you are filtering rows, it should work at the same speed 8.2 Subsetting General form: DT[i, j, by] Meaning: Take DT, subset/reorder rows using i, then calculate j, grouped by by. 8.2.1 Rows You can subset or reorder the rows. Example: flights[origin == &quot;JFK&quot; &amp; month == 6L] You can refer to columns by just their name (as if they were variables) like in dplyr. Using df$ at the start also works though. No need for comma after i (the subsetting or ordering condition), like in base R (e.g. df[col == 'a',]). Works with comma as well. 8.2.1.1 Sorting flights[order(origin, -dest)] This will sort rows first according to origin (in ascending order) and THEN according to dest in descending order, as incidcated by the -. 8.2.2 Columns flights[, arr_delay] returns a vector. If you select two or more columns (dt[,c(col1, col2)]) it returns a vector of the two columns joined together (thus length = 2 x length of df). If you provide the column names in the form of a list, a data.table is returned. You can use eitherflights[, list(arr_delay)] or flights[, .(arr_delay)]. Note .() is short for list() in data.table. You can also rename columns (when using list) like so: flights[, .(delay_arr = arr_delay, delay_dep = dep_delay)] 8.2.2.1 Column name as variable To select columns using column names provided in the form of a variable (e.g. argument in a function) there are a few ways. You can use with = TRUE. Outputs a data.table. var1 &lt;- &quot;dep_time&quot; var2 &lt;- &quot;arr_time&quot; dt1 &lt;- flights[,c(var1,var2), with=FALSE] From documentation: with: By default ‘with=TRUE’ and ‘j’ is evaluated within the frame of ‘x’ (the data.table); column names can be used as variables. This means, line in dplyr, you can use the column name and do not have to specify the dataframe (e.g. df$colname). This is called non-standard evaluation. When ‘with=FALSE’ ‘j’ is a character vector of column names or a numeric vector of column positions to select, and the value returned is always a ‘data.table’. ‘with=FALSE’ is often useful in ‘data.table’ to select columns dynamically. This makes the data.table act like a ‘normal’ dataframe. Though note that the output is a data.table. You can also use get(). Outputs a data.table. dt[ , get(var1)] get() returns the value of a named object (e.g. if you give it the name of a variable, it returns what that variable is assigned to) Note that running just get(var1) will give you an error: get(var1) ## Error in get(var1): object &#39;dep_time&#39; not found Only when it is evaluated in the context of the data.table (see with=TRUE above) will it work. In the context of the data.table, the value of the variable is a column name. Use quote() and eval(). Outputs a vector. This is similar to writing functions with dplyr (see section 7.4.2. var1 = quote(colname) dt[ , eval(var1)] Example: var1 &lt;- quote(arr_time) str(var1) ## symbol arr_time str( flights_dt[,eval(var1)] ) ## int [1:327346] 830 850 923 1004 812 740 913 709 838 753 ... Note again how this does not work outside of the context of the data.table. eval(var1) ## Error in eval(var1): object &#39;arr_time&#39; not found Use quote() and eval(). Outputs a data.table. var1 &lt;- quote(list(x, v)) DT[ , eval(var1)] Example: var1 &lt;- quote(list(dep_time, arr_time)) str(var1) ## language list(dep_time, arr_time) str(flights_dt[ , eval(var1)]) ## Classes &#39;data.table&#39; and &#39;data.frame&#39;: 327346 obs. of 2 variables: ## $ dep_time: int 517 533 542 544 554 554 555 557 557 558 ... ## $ arr_time: int 830 850 923 1004 812 740 913 709 838 753 ... ## - attr(*, &quot;.internal.selfref&quot;)=&lt;externalptr&gt; See this SO question for more. 8.3 Functions This gives you one number, the number of trips with a arrival and departure delay of 0. flights_dt[, sum( (arr_delay + dep_delay) &lt; 0 )] ## [1] 188401 This filters the rows, then gives you the number of rows left - note that here we could have put any column name in length(). flights_dt[origin == &quot;JFK&quot; &amp; month == 6L, length(dest)] ## [1] 9182 := is to be used within ‘j’ only. It adds or updates or removes column(s) by reference. It is much faster. read this blog: http://brooksandrew.github.io/simpleblog/articles/advanced-data-table/#create-multiple-columns-with--in-one-statement and this: https://stackoverflow.com/questions/7029944/when-should-i-use-the-operator-in-data-table 8.4 Grouping Use the last (by) section to group. If you are grouping by just one variable you can use by=var1, otherwise you need to put in list or vector - by=list(var1,var2) or by=.(var1,var2) or by=c(var1,var2). You can perform functions on your groups: head( flights_dt[carrier == &quot;AA&quot;, .(mean(arr_delay), mean(dep_delay)), by = .(origin, dest, month)] ) This returns a data.table with: the columns that you grouped by. the two new mean columns. They are named v1 and v2 by default, but you can name then by using .(name1 = mean(arr_delay), name2 = mean(dep_delay)). To get the number of rows (or elements) in each group, you can use .N. head( flights_dt[carrier == &quot;AA&quot;, .N, by = .(origin, dest)] ) ## origin dest N ## 1: JFK MIA 2197 ## 2: LGA ORD 5491 ## 3: LGA DFW 4661 ## 4: EWR MIA 1058 ## 5: LGA MIA 3888 ## 6: JFK SJU 1085 The output is the number of rows in each of your groups. 8.4.1 Expressions by can also take expressions. flights_dt[, .N, .(dep_delay&gt;0, arr_delay&gt;0)] ## dep_delay arr_delay N ## 1: TRUE TRUE 92303 ## 2: FALSE FALSE 158900 ## 3: FALSE TRUE 40701 ## 4: TRUE FALSE 35442 You get a TRUE and FALSE group for each expression, and all possible combinations of your expressions (here there are four in total). Here the number of rows was also calculated due to the inclusion of .N. 8.4.2 Order by keeps the order of your groups as they appear in the datatable. keyby orders the rows by the grouping variables, in increasing order (See section 888 for more on keys.) 8.4.3 Functions on groups There is a .SD symbol in data.table and it stands for ‘Subset of Data’. When you group by, it gives you each group, in the order as they appear in your data.table. flights_dt[ , lapply(.SD, mean), by = month, .SDcols = c(&quot;arr_delay&quot;, &quot;dep_delay&quot;)] There are a few things to note: The output of lapply() is a list. Recall that for section ‘j’, as long as the output is a list, data.table will give you each element of the list as a column in your new data.table. .SDcols allows us to specify which columns we which to perform the function on. data.table will otherwise by default try to perform the function on all columns. 8.5 Keys Useful references: The data.table key vignette this question on SO. You can set one or more columns as ‘keys’ in your data table. These columns can be of any data type and uniqueness is not forced (you can have rows with the same value). What keys do: Reorders the rows of the data.table by the key, in increasing order. Marks those columns as key columns (by setting an attribute called ‘sorted’). The setkey() function lets you set the key. You do not need to assign the output to a variable - it is modified in place. To find out the keys of a datatable, use the function key(). What you can do after you set a key: Subset DT[.('rowvalue', 'rowvalue2')] - here you are querying the key columns, using the .() (list()) notation. The output is the rows where the first key column has the value ‘rowvalue’ and the second key column has the value ‘rowvalue2’. You can put as many values as you have keys. To be able to subset only ONE of the key columns you need something like this: dt[ .(unique(key1), 'rowvalue2') ]. You cannot skip the first key, thus you put all the values of the first key there. 8.6 set The := function is called set (?) and it allows you to update or create new columns ‘by reference’. 8.7 Reshaping melt() - wide to long. See this vignette for more. melt(DT, id.vars = c(&quot;col1&quot;, &quot;col2&quot;), measure.vars = c(&quot;col3&quot;)) measure.vars specifies the columns to make long. You can refer to columns via indices. If a column is factor, you can set variable.factor argument to FALSE to prevent return character data type instead. If either id.vars or measure.vars is missing, the rest of the columns are automatically assigned to the missing argument. Use argument variable.name and value.name to specify names of the columns. dcast() long to wide. dcast(DT, col1 + cl1 ~ col3, value.var = &quot;name&quot;) Formula notation - LHS is the id columns, RHS measurement columns. value.var let’s you specify the prefix to add the column names. Useful if there are more than one measurement columns. 8.8 Merge data.table will by default merge using the ‘key’ column of the data.table. Recall you can set the key using the function setkey(). You can also set the key on a ‘case by case’ basis using on (X[Y, on=c(&quot;x_a&quot; = &quot;y_a&quot;)]). If you have several columns to merge by, add another element to your vector for the ‘on’ argument. See this question on SO for more. "],
["plotting-in-r.html", "Chapter 9 Plotting in R 9.1 Base R plotting 9.2 par 9.3 Combining plots 9.4 Text 9.5 Lines 9.6 Legend 9.7 Two axis 9.8 Palette", " Chapter 9 Plotting in R Useful references: Roger Peng’s guide (much of the notes at the beginning are copied from here) Idiot’s Guide The core plotting and graphics engine in R is encapsulated in the following packages: graphics: contains plotting functions for the ‘base’ graphing systems, including plot, hist, boxplot and many others. grDevices: contains all the code implementing the various graphics devices, including X11, PDF, PostScript, PNG, etc. There are three main graphics systems for making a plot: base - usually constructed piecemeal, with each aspect of the plot handled separately through a series of function calls. Conceptually simpler. lattice - usually constructed in a single function call, so all of the graphics parameters have to be specified at once. This allows R to automatically calculate the necessary spacings and font sizes. ggplot2 - combines concepts from both base and lattice but uses an independent implementation. These generally cannot be mixed. This chapter will discuss base R plotting. ggplot2 will be discussed in the next chapter. 9.1 Base R plotting There are two ‘phases’ to making a plot: Initialising a new plot (e.g. with plot() or hist(), which will launch a graphics device and draw a plot on the device.) Annotating (adding to) an existing plot Example of basic plot: plot(1:5,1:5) The default method for plot() is creates a scatter plot and will be used unless the R object input is of some special class. Base plotting functions (e.g. plot() and boxplot()) share a set of parameters. Here are some useful ones: pch: the plotting symbol (default is open circle). The different symbols and their corresponding number are shown here: You can also set pch to a letter, and that letter will be shown at each point. lty: the line type (default is solid line), can be dashed, dotted, etc. lwd: the line width, specified as an integer multiple. col: the plotting color, specified as a number, string, or hex code; the colors() function gives you a vector of colors by name. xlab: character string for the x-axis label. ylab: character string for the y-axis label. main: title of the plot. type: what type of plot should be drawn e.g. 'p' for points, 'b' for both. cex: size of points. Scatter plot with appearance changes. plot(1:5,1:5, type = &#39;b&#39;, pch = 0, lty = 2, main = &quot;title&quot;, col = &quot;darkgreen&quot;) You can also colour the points according to a factor vector of the same length as the number of data points, by setting col to be this vector. Default colours will be used. plot(iris$Sepal.Length, iris$Petal.Length, col = iris$Species, pch = 15) You can also provide col with a character vector of colour names the same length as the number of data points. The col argument actually sets the colour of the border of each point. bg sets the colour of the ‘backgroud’ of each point. This can only be set for point shapes that are ‘empty’ in the middle. plot(iris$Sepal.Length, iris$Petal.Length, col = iris$Species, pch = 21) plot(iris$Sepal.Length, iris$Petal.Length, col = iris$Species, pch = 21, bg = &quot;blue&quot;) 9.2 par The par() function specifies global parameters that affect all plots in an R session. Of course these parameters las: the orientation of the axis labels on the plot. bg: the background color. mar: the margin size. oma: the outer margin size (default is 0 for all sides). mfrow: layout of plots using syntax mfrow=c(nrows, ncols), plots are filled row-wise. mfcol: layout of plots using syntax mfcol=c(nrows, ncols), plots are filled column-wise. 9.3 Combining plots This can be done using the arguments mfrow or mfcol in par(). par(mfrow = c(2,1)) plot(1:5,1:5) plot(1:5,1:5) The layout() function gives you more flexibility. This function takes a matrix, which specifies the location of the figures to plot layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE)) hist(mtcars$wt) hist(mtcars$mpg) hist(mtcars$disp) The matrix above looks like this: matrix(c(1,1,2,3), 2, 2, byrow = TRUE) ## [,1] [,2] ## [1,] 1 1 ## [2,] 2 3 It essentially splits the plotting ‘window’ into 4 quadrants, and specified that the first plot should take the first row consisiting of 2 quandrants and plots 2 and 3 take the second row of quandrants. You can also add widths and heights arguments to layout() to specify the size of each quandrant (the number of sections would of course depend on each matrix, but there are four in our case). layout(matrix(c(1,1,2,3), 2, 2, byrow = TRUE), widths=c(2,1), heights=c(2,1)) hist(mtcars$wt) hist(mtcars$mpg) hist(mtcars$disp) You can also manipulate plot arrangement using fig in par(): par(fig=c(0,0.8,0,0.8)) plot(mtcars$wt, mtcars$mpg, xlab=&quot;Car Weight&quot;, ylab=&quot;Miles Per Gallon&quot;) par(fig=c(0,0.8,0.45,1), new=TRUE) boxplot(mtcars$wt, horizontal=TRUE, axes=FALSE) par(fig=c(0.65,1,0,0.8),new=TRUE) boxplot(mtcars$mpg, axes=FALSE) mtext(&quot;Enhanced Scatterplot&quot;, side=3, outer=TRUE, line=-3) First think of the full graph as going from (0,0) on the lower left corner to (1,1) on the top right hand corner. The first fig=c(0,0.8,0,0.8) specifies the size of the scatter plot. The syntax of the four numbers is c(x1,x2,y1,y2). On the horizontal axis, the plot goes from 0 to 0.8. On the vertical axies, the plot goes from 0 to 0.8. The top boxplot goes from 0 to 0.8 on the horizontal axis. On the vertical axis, the top boxplot goes from 0.45 to 1. These figures usually require some trial and error to find the ones needed for the desired appearance. Note that this boxplot was located differently when run in the console vs when using knitr. Setting new=TRUE tells R to make the next plot without cleaning the graphics device. Reference: Quick-R 9.4 Text The text() function allows you to add text to your plot. plot(1:5,1:5) text(x = 1.5, y = 4, labels = &quot;R2 = 0.896\\nP = 2.615e-15&quot;) The x and y arguments specify where on the axis (as determined by the y and x axis of the graph) the text should be. Including &quot;\\n&quot; in the text will insert a new line. 9.5 Lines The function abline() lets you add a new line 9.6 Legend 9.7 Two axis https://stackoverflow.com/questions/6142944/how-can-i-plot-with-2-different-y-axes 9.8 Palette Colour blind friendly palette - 15 hues: pal &lt;- c(&quot;#000000&quot;,&quot;#004949&quot;,&quot;#009292&quot;,&quot;#ff6db6&quot;,&quot;#ffb6db&quot;, &quot;#490092&quot;,&quot;#006ddb&quot;,&quot;#b66dff&quot;,&quot;#6db6ff&quot;,&quot;#b6dbff&quot;, &quot;#920000&quot;,&quot;#924900&quot;,&quot;#db6d00&quot;,&quot;#24ff24&quot;,&quot;#ffff6d&quot;) Use: 1,6,11, 2,7,12 20 distinct colours (Link): pal2 &lt;- c(&quot;#000000&quot;, &quot;#800000&quot;, &quot;#4363d8&quot;, &quot;#f58231&quot;, &quot;#808000&quot;, &quot;#469990&quot;,&quot;#000075&quot;, &quot;#9A6324&quot;, &quot;#911eb4&quot;, &quot;#3cb44b&quot;, &quot;#e6194B&quot;, &quot;#f032e6&quot;, &quot;#42d4f4&quot;, &quot;#bfef45&quot;, &quot;#ffe119&quot;, &quot;#a9a9a9&quot;, &quot;#e6beff&quot;, &quot;#fabebe&quot;, &quot;#aaffc3&quot;, &quot;#ffd8b1&quot;) "],
["ggplot2.html", "Chapter 10 ggplot2 10.1 Introduction 10.2 geom_point 10.3 Bar graphs &amp; histograms 10.4 geom_boxplot 10.5 Facets 10.6 Reordering factors 10.7 Coordinate systems 10.8 Reference lines 10.9 Error bars 10.10 Appearance 10.11 dplyr &amp; ggplot2 10.12 Saving graphs", " Chapter 10 ggplot2 Useful references: ggplot2 extensions Theory of ggplot Themes 10.1 Introduction The general syntax of a ggplot2 call: ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, #statistical transformation position = &lt;POSITION&gt;) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; There are 7 parameters to specify but you will rarely have to specify all 7 parameters as ggplot has useful defaults. 10.1.1 geoms Different types of graphs are called different ‘geoms’, as they can be thought of geometrical objects used to represent data. E.g.: geom_bar = bar graph geom_line = line graph geom_boxplot = box plot geom_point = scatter plot geom_smooth = smooth line fitted to the data 10.1.2 Layering Think of ggplot2 as creating a plot using layers. Here is a simple scatter plot: ggplot(data = iris) + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width)) We can break this down into ‘layers’. This creates an empty graph: ggplot(data = iris) geom_point() creates a scatter plot on top of the empty base. ‘mapping’ is an argument you beed to define. It maps variable to a way to show it on graph or ‘defines how variables in your dataset are mapped to visual properties’. Mapping is always paired with aes() and the x and y arguments of aes(), which specify which variable is x and which one is y. ggplot(data = iris) + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width)) 10.1.3 Aesthetics The specific mapping = aes() options vary depending on the type of geom. For geom_point, the following mapping options are available: colour - colour of the points. size - where each dot will be different sizes depending on the class it belongs to. You can also control the min and max range of point sizes with: scale_size_continuous/discrete(range = c(2,4)) - depending on whether the variable is continuous or discrete. alpha - transparency of points. shape - shape of the points. ggplot2 will only use 6 shapes at a time. By default additional groups will be unplotted. A different variable can be mapped to each of these aesthetics. ggplot selects a reasonable scale and constructs a legend. (The dataset mpg will be used in this section) Here colour is mapped to the variable (column) class. ggplot(data = iris) + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width, colour = Species)) You can also set aesthetics to a SINGLE value manually. Do this by mapping aesthetic name outside of the aes() function. This makes all the points blue: ggplot(data = iris) + geom_point(mapping = aes(x = Sepal.Length, y = Sepal.Width), colour = &quot;blue&quot;) You can also specify these aesthetic appearance mappings: size - you can specify size of all points in mm shape - specify using a number code. The shapes available are: stroke - for shapes that have a border, this dictates the size of the border, in mm. Here we add a border to all the points: ggplot(data = iris, mapping = aes(x = Petal.Length, y = Petal.Width, fill = Species)) + geom_point(colour = &quot;black&quot;, shape = 21, stroke = 1, size = 4) It is important to note the difference between mapping an aesthetic within aes() and outside of aes() - within aes() you can map a variable (or column) to an aesthetic outside of aes() (but inside a geom) you can only map an aesthetic to a constant value (See SO for more details) Further, if you do try to provide a colour to a mapping within aes() ggplot2 will interpret it as a variable. ggplot(iris, aes(x = Petal.Width)) + geom_line(aes(y = Sepal.Length, colour = &quot;red&quot;)) + geom_line(aes(y = Petal.Length, colour = &quot;blue&quot;)) The legend labels are &quot;blue&quot; and &quot;red&quot; because ggplot2 has interpreted these to be the labels of each line. ggplot2 also maps the variables &quot;blue&quot; and &quot;red&quot; to the default colour pallete in alphabetical order. Notice how in the legend &quot;blue&quot; occurs first. If you add legend labels - notice how labels are mapped to your &quot;blue&quot; and &quot;red&quot; NOT according to the order the appear in, in the code, but in alphabetical order (&quot;blue&quot; first). See this question on SO for more. ggplot(iris, aes(x = Petal.Width)) + geom_line(aes(y = Sepal.Length, colour = &quot;red&quot;)) + geom_line(aes(y = Petal.Length, colour = &quot;blue&quot;)) + scale_colour_discrete(labels = c(&quot;first&quot;, &quot;second&quot;)) 10.1.4 Syntax If you put mappings at the top in ggplot(), it will use such mapping for everything, ‘global mapping’. Here the same y and x mappings are used to create points and a smooth line. ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; The above code means the same as: ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy)) + geom_smooth(mapping = aes(x = displ, y = hwy)) You can still change mappings for specific geoms, even if you have specified a ‘global’ mapping in ggplot() call. If you add mappings to geom_xx(), ggplot2 will overwrite or extend the global mappings given in ggplot() with the local mappings given in geom_xx(). Again we can consider geom() as another layer underneath ggplot(), and any changes are for the layer geom(). Here, we add the colour variable to just the geom_point() layer. ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + geom_point(mapping = aes(color = class)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; You can also simplify the syntax as data = and mapping = are the first arguments to the ggplot() and geom_xx() functions. 10.1.5 Stat Stat stands for ‘statistical transform’ and is the algorithm used by a geom to calculate the values used for the graphs. You can find the default stat by looking in the help file of that geom. You can use stat and geom interchangeably. For example, the default stat for geom_bar() is stat_count(). # this code: ggplot(iris) + stat_count(aes(x = Species)) # is the same as: ggplot(iris) + geom_bar(aes(x = Species)) The help file for geom_bar() will also document what values are computed for this stat. stat_count() computes 2 values: count and prop. You can override the default stat with the stat argument in geom_xx(). You can also change the default mapping e.g. so that a bar graph of proportion is shown instead of counts. ggplot(iris) + geom_bar(aes(x = Species, y = ..prop.., group = 1)) Note that proportion is now on the y axis. The argument group = 1 means that it will treat all observations as 100% and calculated the proportion of observations in each group. Without this argument, the proportion will be 100% for each group as it will treat each group separately. 10.2 geom_point The iris dataset will be used for this section. 10.2.1 Jitter A problem with scatter plots is that if there are many values that are the same number (especially if they are rounded), the points will overlap each other and it will be diff to appreciate from the graph where the weight of the points lie. To overcome this you can separate the points by adding a bit of random noise to each point. You can do this in two ways: ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy), position = &quot;jitter&quot;) or in a shorter way (as geom_point(position = &quot;jitter&quot;) = geom_jitter()): ggplot(mpg) + geom_jitter(aes(x = displ, y = hwy)) 10.2.2 Labels To label points, use geom_text: ggplot(iris, aes(y = Petal.Width, x = Petal.Length)) + geom_point() + geom_text(aes(label = iris$Species)) If you only wanted to label a few specific points, you can use ifelse(): ggplot(iris, aes(y = Petal.Width, x = Petal.Length)) + geom_point() + geom_text(aes(label = ifelse(iris$Petal.Length &gt; 6.2, as.character(iris$Species), &quot;&quot;)), hjust = 0.5, vjust = 1) Note that in the ifelse() statement, you specify the label to be empty &quot;&quot; if the value (row) does not meet your condition. The arguments hjust and vjust change the position of the label. Note that these are arguments to geom_text() and not aes(). Overlapping labels is a common problem. The package ggrepel ( link ) solves this problem. library(ggrepel) ggplot(iris, aes(y = Petal.Width, x = Petal.Length)) + geom_point() + geom_text_repel(aes(label = ifelse(iris$Petal.Length &gt; 6.2, as.character(iris$Species), &quot;&quot;))) Note that you no longer use geom_text(). We also put the label argument within geom_text_repel(aes()). You can also the label argument within ggplot, so it is set ‘globally’. 10.2.3 Colour points If you use the aesthetic fill to colour points using a categorical variable, ggplot2 will set different colours for each category. If you use a continuous variable, ggplot2 will set a gradient scale with appropriate min and max values. To colour specific points you can use cut() with scale_colour_manual(): ggplot(iris, aes(y = Petal.Width, x = Petal.Length, colour = cut(iris$Petal.Length, c(0,6,10)))) + geom_point() + scale_colour_manual(name = &quot;legend&quot;, values = c(&quot;red&quot;, &quot;black&quot;)) The function cut() divides a vector into intervals. You can either specify break points (as I have above - note providing 3 numbers breaks the vector into 2 intervals) or specify the number of intervals you want, in the breaks argument. The result is a factor, where each level is an interval. The scale_colour_manual() function lets you specify which colours you wish to use. You can also modify the legend by changing the name and the legend labels. Here we will change the legend labels: ggplot(iris, aes(y = Petal.Width, x = Petal.Length, colour = cut(iris$Petal.Length, c(0,6,10)))) + geom_point() + scale_colour_manual(name = &quot;legend&quot;, values = c(&quot;red&quot;, &quot;black&quot;), labels = c(&quot;less than 6&quot;, &quot;larger than 6&quot;)) You can also do this by calling geom_point() twice, specifying only selected points in the second call and setting these points to be a specific colour (see: SO ). 10.2.4 Matrix of plots Base R comes with the function pairs() which creates a matrix of scatter plots. pairs(iris[,1:4]) The GGally package is an extension to ggplot2 and has a function called ggpairs() which offers extra functionality, like letting you use non-continuous variables in your data frames. library(GGally) ggpairs(iris, aes(colour = Species, alpha = 0.4)) 10.2.5 Adding lines geom_line() allows you to add a simple line that joins all the points: ggplot(iris[1:3,], aes(y = Petal.Length, x = Sepal.Length)) + geom_point() + geom_line() To change the appearance of the line, geom_line() offers the following arguments: colour linetype size Setting linetype within geom_line(aes()) allows you have different line types depending on the factor. See R cookbook for more details. geom_smooth allows you to fit a smooth line through all the points using various methods. The default is ‘auto’ which picks one of: lm glm gam loess depending on the size of the largest group. A message will be output along with the plot informing the user of which method was used. ggplot(iris, aes(y = Petal.Width, x = Petal.Length)) + geom_point() + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; More details can be found in the ggplot2 reference. For a plot where x-axis was a categorical/ordinal variable, you can use stat_summary() to draw a line joining the means (or some other function) of each group. stat_summary() operates on unique x and are more flexible versions of stat_bin() - they can compute any aggregate instead of just count. ggplot(iris, aes(y = Sepal.Length, x = Species)) + geom_point() + stat_summary(aes(group = 1),fun.y = mean, geom = &quot;line&quot;) Note that it is important to set the group aesthetic - this tells ggplot if there are groupings within each unique x. 10.2.5.1 Grouping You may need to specify aes(group()) within geom_line() if you wish to join lines within groups only. iris %&gt;% group_by(Species) %&gt;% summarise(meanSep = mean(Sepal.Length), meanPet = mean(Petal.Length)) %&gt;% gather(2:3, key = &#39;type&#39;, value = &#39;mean&#39;) ## # A tibble: 6 x 3 ## Species type mean ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 setosa meanSep 5.01 ## 2 versicolor meanSep 5.94 ## 3 virginica meanSep 6.59 ## 4 setosa meanPet 1.46 ## 5 versicolor meanPet 4.26 ## 6 virginica meanPet 5.55 This will give a warning: iris %&gt;% group_by(Species) %&gt;% summarise(meanSep = mean(Sepal.Length), meanPet = mean(Petal.Length)) %&gt;% gather(2:3, key = &#39;type&#39;, value = &#39;mean&#39;) %&gt;% ggplot(aes(y = mean, x = Species, colour = type)) + geom_point() + geom_line() ## geom_path: Each group consists of only one observation. Do you need to ## adjust the group aesthetic? Default grouping occurs in two ways: If x or y are categorical variables, this will become the default group If colour, shape or fill is used, data will be grouped according to the variable mapped to. In the above case, x was set to Species and colour to type - thus there is only one observation per group, as per the warning message. There are a few ways to avoid default grouping: do not use map in ggplot(aes()) as this will be applied to all layers override the default grouping with the group parameter Here we have overriden the default grouping in the geom_line() geom: iris %&gt;% group_by(Species) %&gt;% summarise(meanSep = mean(Sepal.Length), meanPet = mean(Petal.Length)) %&gt;% gather(2:3, key = &#39;type&#39;, value = &#39;mean&#39;) %&gt;% ggplot(aes(y = mean, x = Species, colour = type)) + geom_point() + geom_line(aes(group = type)) You can also remove all grouping by setting group to be a constant - any one value, e.g. 1, or 123, or ‘aa’. This makes the geom treat all the data as one group and draw one line through all the data points. Note also that you can do this within aes() or outside of aes() as it is a constant (see section 10.1.3). iris %&gt;% group_by(Species) %&gt;% summarise(meanSep = mean(Sepal.Length), meanPet = mean(Petal.Length)) %&gt;% gather(2:3, key = &#39;type&#39;, value = &#39;mean&#39;) %&gt;% ggplot(aes(y = mean, x = Species, colour = type)) + geom_point() + geom_line(group = 1) Finally, note that grouping is for collective geoms. Collective geoms are geoms which ‘use’ more than one row of data. In geom_point(), each point is one row of data, thus it is NOT a collective geom. In geom_boxplo(), each box uses data from many rows, thus it is a collective geom. Grouping is important for collective geoms but NOT for individual geoms. (See link for more details) 10.3 Bar graphs &amp; histograms The default stat of geom_bar() is ‘count’, which ‘bins’ your data (puts each value into a defined ‘bin’), and then plots bin counts. ggplot(iris, aes(x = Species)) + geom_bar() This tells you that there are 50 values (observations/rows) in each species group. geom_histogram() is appropriate for a continuous variable: ggplot(iris, aes(x = Petal.Length)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. A message will be output with the plot telling the user which bin width has been used. To pick a binwidth, use the binwidth argument in geom_histogram() (outside of aes()). A number of histograms can be overlayed on top of each other, though Hadley recommends that you do this with geom_freqpoly(): ggplot(iris, aes(x = Sepal.Width, colour = Species)) + geom_freqpoly() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. To plot a bar graph using absolute values (instead of frequencies), use stat = 'identity' (see 888 chapter for dplyr notation): iris %&gt;% group_by(Species) %&gt;% summarise(mean = mean(Sepal.Length)) %&gt;% ggplot(aes(y = mean, x = Species)) + geom_bar(stat = &#39;identity&#39;) Adding fill argument in aes() will create a stacked bar graph: ggplot(iris, aes(x = Sepal.Length, fill = Species)) + geom_bar() Note: fill species the colour of the bar (or point) and colour spefies the colour of the border around the bar (or point). To have the bars next to each other instead of stacked, use position = 'dodge': ggplot(iris, aes(x = Sepal.Length, fill = Species)) + geom_bar(position = &#39;dodge&#39;) Note in the graph above, for lengths where not all species are present, there is only 1 bar that is wider. To fix this - google it… 10.4 geom_boxplot Definitions: * A box that stretches from the 25th percentile of the distribution to the 75th percentile * A line (or whisker) that extends from each end of the box and goes to the farthest non-outlier point in the distribution. * Points (dots) that display observations that fall more than 1.5 times the IQR from either edge of the box. These outlying points are unusual so are plotted individually. 10.5 Facets (Back to the mpg dataset) Another way to add variables is to split into many graphs: ggplot(mpg) + geom_point(aes(x = displ, y = hwy)) + facet_wrap(. ~ class, nrow = 2) # same plot with or without dot The first argument is a ‘formula’, which you create with ~ followed by variable name. Variable should not be a continuous variable. In the above plot, leaving one side empty or using a dot means that only one variable is being facetted. The nrow and ncol arguments let you specify how many rows or columns you want. If you wish to facet using two variables, facet_wrap will look like this: ggplot(mpg) + geom_point(aes(x = displ, y = hwy)) + facet_wrap(drv ~ class, nrow = 2) # same plot with or without dot Graphs for all possible combinations of your two variables are created and arranged as per the nrow and ncol specification - as described by the help file: ‘Wrap a 1d ribbon of panels into 2d’. Note that only combinations where there values are shown. Alternatively you can use facet_grid(): ggplot(mpg) + geom_point(aes(x = displ, y = hwy)) + facet_grid(drv ~ cyl) Here the notation is (row ~ column) - LHS is which variable should be horizontally facetted and RHS is which variable should be vertically facetted. Note that in this case graphs for all possible combinations of the two variables are created, even though some combinations have no values (e.g. the botton left graphs have no points in them). 10.6 Reordering factors Often a specific order of factor levels is desired when plotting. This can be achieved using the base R function reorder(). head( reorder(mpg$manufacturer, mpg$displ, FUN = max), n=20 ) ## [1] audi audi audi audi audi audi audi ## [8] audi audi audi audi audi audi audi ## [15] audi audi audi audi chevrolet chevrolet ## 15 Levels: honda subaru hyundai volkswagen audi land rover ... chevrolet In the above code we have reordered the levels of mpg$manufacturer according to the maximum mpg$displ (engine displacement in litres) value of each factor group. See the reorder help file for more details. ggplot(mpg) + geom_boxplot(aes(x = reorder(class, hwy, FUN = median), y = hwy)) In the above graph, we have reordered the levels of mpg$class according to their median hwy levels. You acn see in the boxplot, that the median hwy levels increase from left to right. 10.7 Coordinate systems Default is Cartesian. coord_flip() switches axis of the graph - rotatwa graph by 90 deg. Good for graphs with long names on the x-axis. coord_cartesian(ylim = c(min,max), xlim = c(min,max)) lets you ‘zoom’ in on a particular part of the graph. 10.8 Reference lines Reference lines can be added to graphs using: geom_abline - diagonal specified by slope and intercept (vertical and horizontal lines can also be drawn) geom_hline - horizontal line geom_vline - vertical line See ggplot reference for examples. 10.9 Error bars To add error bars, you must specify the length of each error bar. For example, if you wished to have +/- standard deviation error bars on a bar graph, you need to have a column in your dataframe with the standard deviation for each bar. If we wanted to plot the mean +/- sd of the Sepal.Length we would need a dataframe with these columns: iris %&gt;% group_by(Species) %&gt;% summarise(mean = mean(Sepal.Length), sd = sd(Sepal.Length)) ## # A tibble: 3 x 3 ## Species mean sd ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 setosa 5.01 0.352 ## 2 versicolor 5.94 0.516 ## 3 virginica 6.59 0.636 To add the error bars, use geom_errorbar(): iris %&gt;% group_by(Species) %&gt;% summarise(mean = mean(Sepal.Length), sd = sd(Sepal.Length)) %&gt;% ggplot(aes(y = mean, x = Species)) + geom_bar(stat = &#39;identity&#39;) + geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd)) To change the appearance of the error bar, there are many options: iris %&gt;% group_by(Species) %&gt;% summarise(mean = mean(Sepal.Length), sd = sd(Sepal.Length)) %&gt;% ggplot(aes(y = mean, x = Species)) + geom_bar(stat = &#39;identity&#39;) + geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), size = 0.3, # thinner lines width = 0.2, # how much of the bar the error bar should span position = position_dodge(0.9) ) position_dodge() preserves the vertical position of an geom while adjusting the horizontal position. (see ggplot ref for more details) For more examples see R cookbook. 10.10 Appearance Change axis name and title: labs(title = &quot;MAIN TITLE&quot;, x = &quot;X-AXIS TITLE&quot;, y = &quot;Y-AXIS TITLE&quot;). Change position of title: theme(plot.title = element_text(hjust = 0.5)). Set which categories appear in barplot/boxplot: xlim(&quot;Category1&quot;,&quot;Category2&quot;). Change colour of fill boxplot/bars: scale_fill_manual(values = c(&quot;Colour1&quot;, &quot;Colour2&quot;), name = &quot;title of Legend&quot;, labels = c(&quot;Label1&quot;,&quot;Label2&quot;)). Change names under each bar/boxplot: scale_x_discrete(labels = c(&quot;bar1&quot;, &quot;bar2&quot;, &quot;bar3&quot;, &quot;bar4&quot;)). Change title text style: theme(title = element_text(face = &quot;bold.italic&quot;, color = &quot;blue&quot;, size = 16)). Change axis name text style: theme(axis.title = element_text(face = &quot;bold.italic&quot;, color = &quot;red&quot;, size = 16)). Legend title/labels: scale_fill_discrete(name = &quot;Legend name&quot;, labels = c()). Angle of labels: theme(axis.text.x = element_text(angle = 90, hjust = 1)). 10.10.1 Scales Scale functions are quite confusing. A few notes: The functions scale_colour_discrete() and scale_fill_discrete() are actually both wrappers around the function discrete_scale() but with useful defaults. scale_colour_discrete ## function (..., h = c(0, 360) + 15, c = 100, l = 65, h.start = 0, ## direction = 1, na.value = &quot;grey50&quot;, aesthetics = &quot;colour&quot;) ## { ## discrete_scale(aesthetics, &quot;hue&quot;, hue_pal(h, c, l, h.start, ## direction), na.value = na.value, ...) ## } ## &lt;bytecode: 0x108e33290&gt; ## &lt;environment: namespace:ggplot2&gt; * You can set the legend title and labels quite easily but the colours with difficulty. You need to use the `palette` argument which takes the name of a function that when called and given an integer, &#39;x&#39;, will give you &#39;x&#39; colours in hex. The function `colorRampPalette()` takes in a vector of colours (usually two or three, in hex format) and will produce a function that when given an integer, will return a character vector of that length, of colours that interpolate the colours given to the original function. E.g. # this creates a function. The two colours given is what will be interpolated. palette_fun &lt;- colorRampPalette(c(&quot;#000000&quot;,&quot;#800000&quot;)) palette_fun(10) ## [1] &quot;#000000&quot; &quot;#0E0000&quot; &quot;#1C0000&quot; &quot;#2A0000&quot; &quot;#380000&quot; &quot;#470000&quot; &quot;#550000&quot; ## [8] &quot;#630000&quot; &quot;#710000&quot; &quot;#800000&quot; The output is ten colours, which range from the first colour “#000000”, to second colour “#800000”. scale_xx_manual() are more flexible functions which allow you to change the legend title and labels as well as the colours. Fonts: cookbook 10.11 dplyr &amp; ggplot2 To make a plot for each group_by(), use do(). See 888 for more details. iris %&gt;% group_by(Species) %&gt;% do(plots=ggplot(data=.) + aes(x=Petal.Width, y=Petal.Length) + geom_point() + ggtitle(unique(.$Species)) ) ## Source: local data frame [3 x 2] ## Groups: &lt;by row&gt; ## ## # A tibble: 3 x 2 ## Species plots ## * &lt;fct&gt; &lt;list&gt; ## 1 setosa &lt;S3: gg&gt; ## 2 versicolor &lt;S3: gg&gt; ## 3 virginica &lt;S3: gg&gt; The output of this is a dataframe where the first column gives the names of the groups (from the group_by()) and the second column is called ‘plots’ (as we specified) and each item is a plot (gg object). To give the plot a title - the name of the group - you can either use: unique(.$Species) - there will only be 1 species type after group_by(). .$Species[1] - this is the first row of the Species column after group_by(). 10.12 Saving graphs Using pdf() or png(): pdf(&#39;name of thing.pdf&#39;) # Generate your plot dev.off() # this closes off the current graphic device ggsave() saves the last plot that you generated. You can specify width, height and units - options are c('in', 'cm', 'mm'). "],
["other-visualisation-packages.html", "Chapter 11 Other visualisation packages 11.1 pheatmap 11.2 VennDiagram", " Chapter 11 Other visualisation packages 11.1 pheatmap Arguments mat - Numeric matrix of the values to be plotted annotation_row - Labels for each row of the heatmap. Dataframe of 1 column and rownames. The rownames should be the same as the names of the rows of the heatmap. The column should be the labels desired. This will appear in a legend on the LHS of the heatmap. (ref) annotation_col - Same as above but for heatmap columns. cluster_row &amp; cluster_col - Logical. If TRUE will perform clustering on the row/columns. main - title of the graph. filename - name of the file to save the graph in. Let’s use the first 10 rows of setosa and versicolor in iris. To prepare the data we need to convert it into a matrix and add rownames. new_iris &lt;- iris[c(1:10,51:60),1:4] new_iris &lt;- as.matrix(new_iris) rownames(new_iris) &lt;- paste(&quot;S&quot;, 1:20, sep = &quot;&quot;) pheatmap::pheatmap(new_iris) Both the columns and rows are clustered using hierarchical clustering (using hclust()). To add row annotations we must create a dataframe with the annotations as one column. The length of the column (i.e. number of rows) must match the number of rows. The row names of this dataframe must correspond to the row names in the the matrix object (here new_iris). annot_row &lt;- data.frame(Species = iris[c(1:10,51:60),5]) rownames(annot_row) &lt;- rownames(new_iris) head(annot_row) ## Species ## S1 setosa ## S2 setosa ## S3 setosa ## S4 setosa ## S5 setosa ## S6 setosa pheatmap::pheatmap(new_iris, annotation_row = annot_row) Note that the column name of annot_row becomes the legend title. The process to add column annotations is the same as above (except with column names). You can also add more than one annotation but adding another column to the annotation dataframe passed to annotation_row or annotation_column. You can also change the colours of the annotation using the c1 &lt;- c(&quot;blue&quot;,&quot;red&quot;) names(c1) &lt;- unique(annot_row$Species) annot_colour &lt;- list(Species = c1) annot_colour ## $Species ## setosa versicolor ## &quot;blue&quot; &quot;red&quot; Note that annotation_colors takes a list, which must be named. The name of each element must correspond to the annotation (name of the annotation column from the annotation dataframe above). Each element of the list is a vector of colours, which also must be named with the unique annotations (e.g. here setosa and versicolor). pheatmap::pheatmap(new_iris, annotation_row = annot_row, annotation_colors = annot_colour) More appearance alterations can be found in this SO question. 11.2 VennDiagram venn.diagram(data, filename = &quot;Venn.png&quot;, imagetype = &quot;png&quot;, main = &quot;Common miRNAs&quot;, print.mode = c(&quot;raw&quot;, &quot;percent&quot;), sigdigs = 2, force.unique = FALSE) "],
["statistics.html", "Chapter 12 Statistics", " Chapter 12 Statistics ANOVA http://www.sthda.com/english/wiki/one-way-anova-test-in-r http://homepages.inf.ed.ac.uk/bwebb/statistics/ANOVA_in_R.pdf "],
["rmarkdown.html", "Chapter 13 Rmarkdown 13.1 Basics 13.2 Knitr 13.3 Bookdown 13.4 HTML on Github", " Chapter 13 Rmarkdown Useful references: R markdown: the definitive guide C Shalizi’s R Markdown for Class Reports Pandoc User’s Guide The difference between markdown and LaTeX, which are both typesetting languages (?). Markdown designed for html. Easy to learn and type but you do not have fine control over typesetting. LaTeX designed for pdf and related outputs. Relatively more difficult to learn but you have control over everything. Note that markdown can create both html and pdf output and same for LaTeX. Pandoc can convert markdown/LaTeX to almost everything. Pages are the source of all (?) problems when the output is not html. In html there are no page breaks and no need to worry about where to place figures, tables and images. Things are able to just appear linearly. Pages result in ‘floating environments’ becase a graph/table cannot be broken over two pages, by default it can float to unexpected places. Rmarkdown is a variant of Markdown developed by RStudio. Can include embedded code chunks. To convert a Rmarkdown document to html (or any markdown document), you can use the markdown package - which uses pandoc for the actual conversion. RStudio includes pandoc, so if you install RStudio, you won’t need to install pandoc separately. 13.1 Basics -- turns into endash (long line). --- turns into emdash (longer line). If you want actual -- (2 dashes) use to escape 2nd dash -\\-. To output text verbatim, surround with backticks. Line break is created using ‘backslash followed by two space characters’, i.e. \\ (ref). 13.2 Knitr Useful references: YiHui’s page on knitr options K Broman’s knitr in a knutshell 13.2.1 YAMAL header Text-based format for specifying data. Example: --- title: &quot;Habits&quot; author: - auth1 - auth2 date: March 22, 2005 output: pdf_document: toc: true toc_depth: 2 --- To get your TOC on a new page (after the title page), use \\newpage after the yaml header. See this SO question for more on including multiple authors. 13.2.2 Chunk options This goes at the top of the code chunk along in {r, }. eval - Logical: whether or not to evaluate the code chunk. Or you can tell it to evaluate certain functions only with eval=c(1,2,3). Numbers seem to refer to ‘expressions’. Expressions numbered thus: Start counting from #1 and each complete line(s) of code counted. If code runs over &gt;1 line (e.g. for loops) it still counts as 1 expression. Each individual empty lines are also counted as onw ‘expression’. E.g. if you have two empty lines before your first line of code, your code line is number 3. Code should still be output (seen) in the file when eval=FALSE. echo - Logical: Include R source code in output file. error - Logical: If you want your error messages to show, turn off error checking using error=TRUE. include - Logical: Include chunk output in final document. If FALSE, nothing outputs except plots. This is not cached. results - Controls text output. ‘Hide’ hides normal R output (does not apply to warnings, messages or errors). So the messages that output after library loading will still display. Can suppresses the console output when generating plots but keeps plots. ‘Hold’ - without this option, output will print after the each line of code (which produces output) within a chunk. Hold will cause all output to be displayed at the end of the chunk. out.width &amp; out.height - Width and height of plots in output. For LaTeX can be 8\\\\linewidth, 3in or 8cm. Can also use percentage '40%' (which is translated to 0.4, when output is latex). message - Logical: stops messages like the ones that output after loading package. cache - Cached code chunks are NOT evaluated. Objects created from these chunks are lazy loaded from previously saved databases (it will save it). Plots fig.keep - Options: ‘high’ - only high quality plots. ‘none’ - discard all. ‘all’ - keep all plots. ‘first’ - only first. ‘last’ - only last. fig.show - ‘hold’ hold all plots and output them at the end of the chunk. Use this when you have comment/lines after your plotting code. Results = ‘hold’ does not work for holding plot output until end of chunk! fig.align - alignment of figure. To get figures to show side-by-side set fig.align=‘center’ &amp; fig.show=‘hold’ (https://stackoverflow.com/questions/37115276/control-alignment-of-two-side-by-side-plots-in-knitr) 13.2.3 Global options Use knitr::opts_chunk$set to set chunk options for all chunks in a document. For example: opts_chunk$set(fig.width=12, fig.height=8, fig.path=&#39;Figs/&#39;, echo=TRUE, warning=FALSE, message=FALSE) 13.2.4 Common problems Code in a code chunk running off the page Set tidy=FALSE. Space your code out how you want to You can also try {r, tidy.opts=list(width.cutoff = 30)}. Plots running off the marging Either on the side or bottom of the page. Mostly occuring when outputting plots from a for loop. The problem is apparently that the generated .tex file has no spaces between the \\includegraphics{} calls. LaTeX gives warnings about overfull hboxes, because the graphics aren’t big enough to sit alone on a line, and are too big when it puts two on each line. See this SO question for an example of the .tex file. A solution is to force each figure to be in its own paragraph. You can do this by essentially putting a blank line between each figure: \\includegraphics{test_files/figure-latex/plot_phenotype-1.pdf} \\includegraphics{test_files/figure-latex/plot_phenotype-2.pdf} \\includegraphics{test_files/figure-latex/plot_phenotype-3.pdf} With blank lines: \\includegraphics{test_files/figure-latex/plot_phenotype-1.pdf} \\includegraphics{test_files/figure-latex/plot_phenotype-2.pdf} \\includegraphics{test_files/figure-latex/plot_phenotype-3.pdf} There are two ways to do this: Add cat('\\r\\n\\r\\r') after each plot. \\r means carriage return, \\n means new line. Add this function to each code chunk: my_plot_hook &lt;- function(x, options){ paste(&quot;\\n&quot;, knitr::hook_plot_tex(x, options), &quot;\\n&quot;) } knitr::knit_hooks$set(plot = my_plot_hook) * The `my_plot_hook` function adds a new line before and after the input graphics. * `hook_plot_tex`, according to the [help](https://www.rdocumentation.org/packages/knitr/versions/1.20/topics/hook_plot_html) file, return the `\\includegraphics{}` command. * [Chunk hooks](https://yihui.name/knitr/hooks/#chunk-hooks) are functions to be called before or after a code chunk when the chunk option is not NULL (it basically means as long as you set a option, the hook will be run). * See [this](https://stackoverflow.com/questions/37030219/r-markdown-plots-within-a-loop-going-out-of-margin-when-typesetting-to-pdf) SO question for more. Non-english alphabet characters Warning messages for non-English alphabet characters (e.g. Greek characters) when plotting, yet plot has correct characters. Warning messages look something like this: Warning: conversion failure on ‘’ in ‘mbcsToSbcs’: dot substituted for You can prevent this by using pdf.options(encoding=''). Note that you need to put this in a code chunk above the problematic code chunk. This is because knitr opens a new graphical device to record plots (by default it is a PDF device). If you out the above code in the same chunk, it is too late to set pdf.options(). To see a list of all possible encodings, run: list.files(system.file('enc', package = 'grDevices')). See this SO question for more. For me, the characters appear correctly when using plotting in the console however appear as dots when knitting to pdf. The following encodings: Greek.enc CP1253.enc allowed the greek character to show, however the greek character is printed on top of the character before it. Another solution suggested is to specify dev='cairo_pdf' in the chunk options (see this SO question for more). YiHui explains the dev chunk option in his website here - search for ‘dev’ or ‘cairo’. This requires you to have the package called “Cairo”. There may be an error with loading this (with library()) on a Mac, as you require the software XQuartz, which does not ship with OS X any more (ref). For me, downloading and installing XQuartz (then restarting the computer so it is the default X11), then re-running the code with dev='cairo_pdf' set worked. I also had to add this to my yaml header to set the latex engine: pdf_document: latex_engine: xelatex Knitr (always?) ‘records’ plots using the pdf() device and then redraws it using the device specified in the chunk option (ref). Warnings (like the conversion failure on above) are generated while knitr is printing the plot to a pdf device. YiHui also has some more information about this, with useful links on his website. 13.3 Bookdown Useful references: YiHui’s Bookdown K Ross’s getting started github page Major output formats: bookdown::pdf_book bookdown::gitbook bookdown::html_book bookdown::epub_book bookdown::render_book - render multiple Rmd documents into a book using the output format functions 13.3.1 Rendering There are 2 approaches to rendering: Merge and knit - merge all chapters into one Rmd file and knitting together. Knit and merge - knit each chapter in a separate R session and merge the markdown output of all chapters to render the book. Differences: In M&amp;K the state of the R session from previous chapters are carried over to later chapters (e.g. objects created in previous chapters are carried over). With K&amp;M, all chapters are isolated from each other. If you use M&amp;K, it can be very difficult to restore a running R session to a completely clean state (e.g. even if you detach/unload packages previously loaded, R will not clean up the S3 methods registered by these packages). No duplicate chunk labels allowed in the M&amp;K approach. K&amp;M does not allow Rmd files to be in subdirectories. Default is M&amp;K. To switch: set new_session = TRUE when calling render_book(), or set new_session: yes in the configuration file ’_bookdown.yml’. 13.3.2 Structure Bookdown merges Rmd files by order of file names (e.g. 01-chap1, 0.2-chap2…). Names that start with an underscore ’_’ will be ignored. index.Rmd file will be the ‘main’ or first file. This is because the HTML file index.html to be generated from index.Rmd, is usually the default index file. To override this, include a configuration file called ’_bookdown.yml’. Here you can define your list and order of Rmd files - rmd_files:[&quot;index.Rmd&quot;, &quot;abstract.Rmd&quot;, &quot;intro.Rmd&quot;] Underscores and ‘index/Rmd’ will not be treated differently if ‘rmd_files’ is included. 13.3.3 YAMAL header These options are passed to the GitBook HTML template via Pandoc. They may not have clear visible effects on the HTML output but may be useful when you deploy the HTML output as a website. description - A character string to be written to the content attribute of the tag &lt;meta name=&quot;description&quot; content=&quot;&quot;&gt; in the HTML heading (if missing, the title of the book will be used). This can be useful for search engine optimization (SEO). Note that it should be plain text without any Markdown formatting such as _italic_ or **bold**. url - The URL of book’s website. E.g. https\\://bookdown.org/yihui/bookdown/ (note the ‘' before’:’) github-repo - The GitHub repository of the book of the form user/repo You can add a Github button in the sharing buttons on the toolbar by setting github:yes under sharing in the gitbook configurations (see bookdown news for more). 13.4 HTML on Github How to render html file on github instead of the raw file - add http://htmlpreview.github.io/? to the start of the page url, once you have opened in github: E.g. http://htmlpreview.github.io/?https://github.com/lucyleeow/StatisticalRethinking/blob/master/Chapter2.nb.html https://github.com/lucyleeow/StatisticalRethinking/blob/master/Chapter2.nb.html Or use rawgit.com: Rendered html: https://rawgit.com/lucyleeow/StatisticalRethinking/master/Chapter2.nb.html Raw html: https://github.com/lucyleeow/StatisticalRethinking/blob/master/Chapter2.nb.html Note ‘blob’ needs to be deleted from the first url as well. Reference SO. "],
["package-development.html", "Chapter 14 Package development 14.1 Naming 14.2 States 14.3 R CMD install 14.4 Workflow 14.5 File structure 14.6 DESCRIPTION 14.7 NAMESPACE 14.8 Documentation", " Chapter 14 Package development Useful references: Hadley Wickham’s R packages Hillary Parker’s quick guide Damjan Vukcevic’s slides 14.1 Naming Can only contain letters, numbers and periods (‘.’) Must start with letter Cannot end with a period Hadley recommends against using periods 14.2 States An R package can exist in five states: 14.2.1 Source Development version. Lives on your computer. It is just a directory with DESCRIPTION file, R/ folder etc. 14.2.2 Bundled Package that has been compressed into a single file. By convention, uses the extension ‘.tar.gz’. This means that several files have been reduced to a single file (.tar) then compressed (gz). devtools::build() will create a bundle of your package. When you decompress a bundle it will look almost the same as your source package. The differences are: Vignettes are built already. In source you may have markdown or latex input. In decompressed bundle, you will only have the html and pdf output. Temp files in source will not be included in the decompressed bundle e.g. things in the ‘src/’ fold. Any files listed in ‘.Rbuildignore’ will not be included. This is useful for files that are needed to generate the output. In the bundle you only need the output file, thus do not need to include the files used to generate it. 14.2.3 Binary package Single file (like a package bundle) but internal structure is different when uncompressed: Instead of R/, there are 3 files that store the parsed functions in an efficient file format. It is basically the result of loading all the R code and then saving the functions with save(). This is what it looks like: The is a ‘Meta/’ directory (one above) that contains a number of Rds files. These files contact cached metadata about the package - like what topics the help files cover and parsed versions of the DESCRIPTION files. These files make package loading faster by caching costly computations. The ‘html/’ directory contains files for html help files. Binaries are platform specific. 14.2.4 Installed Binary package that’s been decompressed into a package library. Installation involves these steps: source -&gt; bundle, bundle -&gt; binary, binary -&gt; installed - however there are often shortcuts available. See section 14.3 (R CMD install) for more details. 14.2.5 In memory Packages must be loaded into memory to use. There is difference between loading and attaching a package - see section 888 (NAMESPACE) for more. 14.2.6 Summary Files present in the root directory for source, bundled and binary versions of devtools. 14.3 R CMD install The command line tool ‘R CMD INSTALL’ can install a source, bundle or binary package. Devtools functions provide wrappers that allow you to access this tool from R rather than from the command line. build() - converts a package source directory into a single bundled file then intalls the package. Wrapper for R CMD build. install() - install a local development package (into your R system library). Wrapper for R CMD install. It reinstalls the package, detaches the currently loaded version the reloads the new version with library() load_all() - roughly simulates what happens when a package is installed and loaded with library(). It will load R code in the /R folder (and compiled shared objects in /src and data files in /data). Won’t be available when you close your R session. It allows you to ‘skip’ install and load a source package directly into memory. Note that you need to use the above three functions from a working directory OUTSIDE of your package directory! This can be easily done with setwd('..'). install_github() - downloads a source package from GitHub, runs build() to make vignettes then uses R CMD install to install. install_url(), install_gitorious(), install_bitbucket() do similar things but just from different websites. install.packages() - looks on CRAN for package, downloads and then installs. The difference between install_github() and install.packages() is that for the latter, packages are often in binary format on CRAN thus do not need to be built before installed. See the devtools package documentation for more. RStudio’s ‘build and reload’ or ‘install and restart’ (depending on the RStudio version) button (or keyboard ‘Ctrl/Cmd + Shift + B’) is similar to load_all(). It lets you skip install and load a source package into memory. It is slower than install_all(). It does not build vignettes like install() does. Build will make a copy of many of the files - problem for large data files. (See this question SO for more). As discussed below in section 14.4 (Workflow), build and reload will show links between your documentation pages. Comparison: Summary of the build functions: An installed package is just a binary package that’s been decompressed into a package library. 14.4 Workflow This describes the package writing workflow using roxygen2 to create the documentation and the NAMESPACE files. You can choose to use roxygen2 to only create the documentation or NAMESPACE. If you do not use any of the tags associated with one, it will not alter either the /man or NAMESPACE files. Create file structure (see section ?? (file system)). Update DESCRIPTION file. Write your functions and put them in your R/ folder. Add roxygen2 comments to your R script to generate documentation and/or update the NAMESPACE file. Use the function document() to generate the documentation and/or NAMESPACE. You do not need to install or load your package first. You do not need to give document any arguments. The default is pgk = '.'. roxygenise() vs document() - Roxygen does live analysis of your source code - loads the code in your package so it can create documentation using values in an R environment, not just source code. roxygenise() - sources all files in R/ document() - sources all files in R/, compiles source code in src/, loads data and generally does an accurate job of simulating package loading It is recommended to use roxygenise() only for simple packages. (See this SO question for more.) Preview documentation with ?fun or help(fun). R looks for an .Rd file containing , parses the file, converts it to HTML and displays it. Generally this looks for Rd files in installed packages BUT if you use load_all(), devtools tells the help() and ? how to work with source packages. This preview does NOT work with intra-package links through! You need to install your package for these to work. Install your package. 14.5 File structure The minimum files required for an R package are: /R fold with all your function files (.R) DESCRIPTION file NAMESPACE file DESCRIPTION file - this file states important things about your package like: Name of package and description of what it does Version number Required packages &amp; their versions and the version of R required Name of author(s) and creator(s) - the creator should be the maintainer of the package NAMESPACE file - here you specify which functions you require from other packages and what functions your package makes available to other packages. /R folder - this folder is where the R functions/code should be. /man folder - this is where your function documentation/help files will be. There are two ways to generate the files and file structure automatically: Use the function devtools::create(&quot;mypackage&quot;) sets up the file structure and provides a skeleton for your DESCRIPTION and NAMESPACE files. Create a new ‘package’ project using New Directory &gt; R package. Fill in the blanks in the resulting window: Both of these options work the same and gets you to the same place. Hadley does NOT recommend using package.skeleton() as this creates extra files you have to delete or modify to get a working package. 14.6 DESCRIPTION This file is the defining feature of a package. It uses the Debian control format (DCF). Each line consists of a field name and a value, separated by colon. When values span several lines, they must be indented, usually with four spaces. Package: mypackage Title: What The Package Does (one line, title case required) Version: 0.1 Authors@R: person(&quot;First&quot;, &quot;Last&quot;, email = &quot;first.last@example.com&quot;, role = c(&quot;aut&quot;, &quot;cre&quot;)) Description: What the package does (one paragraph) Depends: R (&gt;= 3.1.0) # which version of R is required License: What license is it under? LazyData: true Imports: Suggests: The last two are important tags that specify packages that are needed or useful for your package. 14.6.1 Imports Packages listed under imports MUST be present for your package to work. When you install your package, all packages in this list will also be installed if not already. This does NOT mean it will be ‘attached’ to your package (i.e. loaded with library()). Best practice is to explicitly refer to functions from other packages with package::function() in your .R scripts. Note on ‘Depends’: previous to the use of namespaces, `depends’ was the only way to list another package as a dependency. Now use imports instead. This is because depends only loads and attaches the package whereas imports only loads it. This is because you do not want to change the search path of person who is using your package - this makes the package more ‘self-contained’ and minimises changes to the global environment. Hadely recommends you to structure Imports with a new line between each pacakge and the packages listed in alphabetical order. imports: tidyverse, limma 14.6.2 Suggests Put packages here that your package can use but does not require. Packages placed here will not be automatically installed. Thus, you need to check if they are available before using. Listing packages under Suggests is a courtesy to your users - so that you are not forcing them to download rarely needed packages. It also lets them get started with your package as quickly as possible. 14.7 NAMESPACE This is not very important if you are developing packages for yourself but vital if you plan on submitting to CRAN. It ensures that other packages won’t interfere with your code and that your code will not interfere with other packages. It does this with: Imports - the functions that you write will use other functions. Imports defines what functions will be used. Exports - specifies what functions are available outside of your package. Helper functions etc should be made internal functions meaning that are only available within your package and another package cannot easily use them. Generally, you want to export a minimal set of functions to avoid conflicts. Namespaces help with looking up the value of an object associated with a name. 14.7.1 Search paths Adding a package to the search path means that you can use functions from it without specifying which package it comes from (e.g. fun() instead of package::fun()) When you call a function, R looks for it in the global environment first, then in subsequent packages. When you run search(), it will show you where R will look for functions (in order). Example output: Package loading and attaching: Loading - load code, data. Available in memory after loading. NOT in the search path so you cannot access its components without using ::. Confusingly, using package::fun() will automatically load a package if it is not already loaded. It won’t however ‘attach’ a package to the search path, like library() does. Attaching - puts the package in the search path. You cannot attach a package without first loading it BUT you can load a package without attaching it. There are 4 ways to make a package available. Here they are divided into Load (ONLY loads) and Attach (loads and attaches): Hadley recommends that you only use library() and requireNamespace() in specific circumstances. 14.7.2 File syntax This file can be generated by roxygen2. You can specify which functions to export etc directly in the function .R script. There are a few reasons for this: You can tell in your code which functions are being exported. Only have to use @export and you don’t have to worry about the specific directives. Keeps the file tidy. You can import a package several times but it will only appear once in the the NAMESPACE file. It looks something like this: # Generated by roxygen2 (4.0.2): do not edit by hand S3method(as.character,expectation) S3method(compare,character) export(auto_test) export(auto_test_package) export(colourise) export(context) exportClasses(ListReporter) exportClasses(MinimalReporter) importFrom(methods,setRefClass) useDynLib(testthat,duplicate_) useDynLib(testthat,reassign_function) Each line contains a directive (e.g. export(), import()). There are 8 namespace directives: export() - exports functions. exportPattern() - export all functions that match a (regular expression) pattern. exportClasses(), exportMethods - export S4 classes and methods. S3method() - export S3 methods. import() - import all functions from a package. importFrom() - import selected functions. importClassesFrom(), importMethodsFrom() - import S4 classes and methods. useDynLib() - import a function from C. 14.7.3 Exporting Add #’ @export above the function to make it usable outside of your package (not all functions like helper functions are usable ‘inside’ your function - meaning that you can ‘call’ on one function in your package within another function in your package). 14.7.4 Importing NAMESPACE controls which external functions can be used by your package without using ::. Note that ‘Imports’ in the DESCRIPTION file just makes sure a package is installed when yours it. It DOES NOT make functions available. This is the case whether or not the package was attached! It is a convenience for the user - if your package is attached, it also attaches all the packages listed in Depends. This means that when a user loads and attaches your package, they can also use all the functions in Depends without using ::. Hadley recommends for you to list all the require packages in Imports (so that it is installed) but do not import these functions because it is better to refer to it explicitly using package ::fun() - this is to make your code easier to read. To import a function using roxygen2, use: @importFrom package fun. Hadley says it is okay to do this if you are using a function repeatedly, as there is a 5s increase in function evaluation time if you use ::. 14.7.5 Exporting Add #’ @export above the function to make it usable outside of your package (not all functions like helper functions are usable ‘inside’ your function - meaning that you can ‘call’ on one function in your package within another function in your package). 14.8 Documentation Great guide here by K Broman. Documentation can be for your function (or your dataset or class). It is accessed by ? or help(). Documentation should be in a folder called ‘man’ and should be of .Rd format. .Rd is loosely based on LaTeX and are rendered to HTML, plain text and pdf for viewing. 14.8.1 Roxygen2 Roxygen2 is a package that helps you write these documentation files IN your script by turning specially formatted comments into .Rd files. As stated at the top of the roxygen generated .Rd files, you should not edit the .Rd file by hand. 14.8.1.1 Basics Roxygen comments start with #’. All the roxygen comments before a function is called a ‘block’. Each line should be wrapped like your code (at 80 characters). Tags - tags break up blocks and are specified using @tagName. @ needs to be escaped if you want to add a literal ‘@’. Sections - you can add arbitrary sections using the @section tag. Useful for breaking a long details section into several chunks. Section titles: Sentence case, followed by colon, 1 line long. 14.8.1.2 Layout Title - First sentence becomes the title of the documentation. Sentence case. Do NOT end with full stop. Required Description - Second paragraph. Briefly describe what the function does. Required. Details - Third and subsequent paragraph(s). Go into detail about how a function works. Shown after the argument descriptions. Optional. 14.8.1.3 Tags @param - details of function parameters. syntax: @param name description. Specify type of input (string, vector..etc) and what it does. Description should be sentence case and end with a full stop. Document several parameters by separating their parameter names with comma (no space) in ‘name’. @examples - Executable R code showing how to use the function in practice. To show error, use \\dontrun{}. You can also have examples in separate files and give a path to them, and use this syntax - @example path/rel/to/package/root Note lack of ‘s’ at end of example here. @return - Describes the output from the function. @seealso - Point to other useful resources, e.g webpages or another function in your package. @family - Family of related functions, where every function should link to every other function in the family. E.g.: #&#39; @family aggregate functions #&#39; @seealso \\code{\\link{prod}} for products, \\code{\\link{cumsum}} for cumulative #&#39; sums, and \\code{\\link{colSums}}/\\code{\\link{rowSums}} marginal sums over #&#39; high-dimensional arrays. @aliases - Any other alias(es) that should direct the user to this help file. @keywords - Adds standardise keywords. These are optional but there is 1 that may be useful. @keywords internal - can be added to internal package functions. This removes it from the (associated .Rd file) from the package index (meaning a user can not easily access it) and disables some of its automated tests. Example: #&#39; Sum of vector elements. #&#39; #&#39; \\code{sum} returns the sum of all the values present in its arguments. #&#39; #&#39; This is a generic function: methods can be defined for it directly #&#39; or via the \\code{\\link{Summary}} group generic. For this to work #&#39; properly, the arguments \\code{...} should be unnamed, and dispatch is on #&#39; the first argument. #&#39; #&#39; @param ... Numeric, complex, or logical vectors. #&#39; @param na.rm A logical scalar. Should missing values (including NaN) #&#39; be removed? #&#39; #&#39; @return If all inputs are integer and logical, then the output #&#39; will be an integer. If integer overflow #&#39; \\url{http://en.wikipedia.org/wiki/Integer_overflow} occurs, the output #&#39; will be NA with a warning. Otherwise it will be a length-one numeric or #&#39; complex vector. #&#39; #&#39; Zero-length vectors have sum 0 by definition. See #&#39; \\url{http://en.wikipedia.org/wiki/Empty_sum} for more details. #&#39; #&#39; @examples #&#39; sum(1:10) #&#39; sum(1:5, 6:10) #&#39; sum(F, F, F, T, T) #&#39; #&#39; \\dontrun{ #&#39; sum(&quot;a&quot;) #&#39; } #&#39; @export sum &lt;- function(..., na.rm = TRUE) {} 14.8.1.4 Formatting Special characters: @ - marks start of tag. @@ to insert literal ‘@’. % - marks start of a latex comment. \\% to insert literal ‘%’. \\ - marks start of latex escaping. Use \\\\ to insert literal ’'. To manually insert a new line use \\cr (See this SO question for more.) \\emph{} - Italics. \\strong{} - Bold. \\code{} - Inline code. \\preformatted{} - Format as-is. Can be used for multi-line code. Links \\code{\\link{function}} - Link to function in this package. \\code{\\link[package]{function}} - Link to function in another package. \\link[=dest]{name} - Link to ‘dest’, but show/display ‘name’ in documentation output. \\code{\\link[MASS:abbey]{name}} - Link to function in another package, but show name. \\url{http://rstudio.com} - url. \\href{http://rstudio.com}{Rstudio} - a url with custom link text. Lists Numbered: #&#39; \\enumerate{ #&#39; \\item #&#39; \\item #&#39; } Bullet: #&#39; \\itemize{ #&#39; \\item #&#39; \\item #&#39; } Named: #&#39; \\describe{ #&#39; \\item{name}{blah blah} #&#39; \\item{name}{blah blah} #&#39; } 14.8.1.5 Multiple functions There are times where you may want to have greater than one function per .R script: Helper functions - often these use ‘linux’ naming convention where the name of the function starts with a ‘.’ Do not export this function. Similar functions, especially if they have the same parameters. This can be done with @describeIn or @rdname. @describeIn - Good for documenting functions with the same/similar arguments. Generates a new section named ‘Functions’ (or Methods (by class) if you are documenting a method) . This generates a bulleted list describing each function. This is at the end under ‘Details’. The document itself is named the first function, the other functions are documented in the same file. For ALL functions (including the first/main one), use @describeIn &lt;name of 1st fun&gt; &lt;description&gt; above the #' @export of that function. This will give you a bullet point list of all your functions and their individual descriptions. @rdname Overrides the default file name generated by roxygen2 and merges documentation for several objects into one file. Can look something like this: #&#39; @rdname fun1 # you want this function to be documented with fun1 #&#39; @export fun2 # export your 2nd function as usual This generates a file named the first function (as above) and your other functions are documented in the same file. Or you can create a dummy documentation file: #&#39; Basic arithmetic #&#39; #&#39; @param x,y numeric vectors. #&#39; @name arith # dummy file - this will be title of the help file NULL ## NULL #&#39; @rdname arith # your function will be documented under the title of your dummy file add &lt;- function(x, y) x + y #&#39; @rdname arith # same with your second function times &lt;- function(x, y) x * y Here your document is named ‘arith’ and your functions are documented in this document. Notice here that the document name is NOT the same as either of your functions. See the roxygen2 vignette and this SO question for more. 14.8.1.6 Helper functions In a package, you do NOT need to write a helper function above the main functions (which calls the helper function). All the functions are made available. This is of note as roxygen2 will generate a .Rd file for the FIRST function (even if it is marked as internal) and NOT for your subsequent main function. Remember to add #’ @keywords internal above the helper function so users cannot easily use it. See this SO question for more on how to handle helper functions. "]
]
